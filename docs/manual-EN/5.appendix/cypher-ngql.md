# Comparison Between Cypher and nGQL


## Conceptual Comparisons

|Name               | Cypher | nGQL          |
| --- | --- | --- |
|  |  |  |
| vertex, node       | node  | vertex        |
| edge, relationship | relationship    | edge          |
| vertex type        | label   | tag           |
| edge type          | relationship type   | edge type     |
| vertex identifier          | node id generated by default | vid           |
| edge identifier        | edge id generated by default   |<src, dst, rank>  |


## Basic Graph Operations

Name                   | Cypher         | nGQL          |
| --- | --- | --- |
|  |  |  |
| List all labels/tags   | * MATCH (n) RETURN distinct labels(n);  <br/> * call db.labels(); | SHOW TAGS |
| Insert a vertex with a specified type | CREATE (:Person {age: 16}) | INSERT VERTEX <tag_name> (prop_name_list) VALUES \<vid>:(prop_value_list) |
| Insert an edge with specified edge type | CREATE (src)-[:LIKES]->(dst) <br/> SET rel.prop = V | INSERT EDGE <edge_name> ( <prop_name_list> ) VALUES <src_vid> -> <dst_vid>: ( <prop_value_list> ) |
| Delete a vertex | MATCH (n:A)  <br/> DETACH DELETE n | DELETE VERTEX \<vid> |
| Delete an edge  | MATCH ()-[r:LIKES]->() <br/> DELETE r | DELETE EDGE <edge_type> \<src_vid> -> \<dst_vid> |
| Update a vertex property |SET n.name = V | UPDATE VERTEX \<vid> SET <update_columns> |
| Fetch vertice prop| MATCH (n) <br/> WHERE id(n) = vid  <br/> RETURN properties(n) | FETCH PROP ON <tag_name> \<vid>|
| Fetch edges prop  | MATCH (n)-[r:FOLLOW]->() <br/> WHERE id(n)=vid <br/> return properties(r)| FETCH PROP ON <edge_name> <src_vid> -> <dst_vid> |
| Query a vertex along specified edge type |MATCH (n)-[r:FOLLOW]->() | GO FROM \<vid> OVER  \<edge> |
| Query a vertex along specified edge type reversely | MATCH (n)<-[r:FOLLOW]-()| GO FROM \<vid>  OVER \<edge> REVERSELY |
| Query N hops along a specified edge |MATCH (n)-[r:FOLLOW*1..N]->() <br/> WHERE id(a) = vid <br/> return r | GO N STEPS FROM \<vid> OVER \<edge> |
| Find path between two vertices |MATCH p =(a)-[]->(b) <br/> WHERE id(a) = vid <br/> RETURN p | FIND ALL PATH FROM \<vid> TO \<vid> OVER * |

## Example Queries

The example queries are based on the graph below:

![image](https://user-images.githubusercontent.com/42762957/71503167-0e264b80-28af-11ea-87c5-76f4fd1275cd.png)

- Insert data
  
```
  # insert vertex
  nebula> INSERT VERTEX character(name, age, type) VALUES hash("saturn"):("saturn", 10000, "titan"), hash("jupiter"):("jupiter", 5000, "god");

  # insert edge
  nebula> INSERT EDGE father() VALUES hash("jupiter")->hash("saturn"):();

  // cypher
  cypher> CREATE (src:character {name:"saturn", age: 10000, type:"titan"})
        > CREATE (dst:character {name:"jupiter", age: 5000, type:"god"})
        > CREATE (src)-[rel:father]->(dst)
 ```
 

- Delete vertex
  
  ```bash
  nebula> DELETE VERTEX hash("prometheus");
  
  cypher> MATCH (n:character {name:"prometheus"})
        > DETACH DELETE n 
  ```

- Update vertex

```bash
nebula> UPDATE VERTEX hash("jesus") SET character.type = 'titan';

cypher> MATCH (n:character {name:"prometheus"})
      > SET n.type = 'titan';
```

- Fetch data
  
  ```bash
  nebula> FETCH PROP ON character hash("saturn");
  ===================================================
  | character.name | character.age | character.type |
  ===================================================
  | saturn         | 10000         | titan          |
  ---------------------------------------------------

  cypher> MATCH (n:character {name:"prometheus"})
        > RETURN properties(n);
  ```

- Find the name of hercules's grandfather

    ```bash
    nebula> GO 2 STEPS FROM hash("hercules") OVER father YIELD  $$.character.name;
    =====================
    | $$.character.name |
    =====================
    | saturn            |
    ---------------------

    cypher> MATCH (src:character{name:"prometheus"})-[r:father*2]->(dst:character)
          > RETURN dst.name;
    ```

- Find the name of hercules's father

    ```bash
    nebula> GO FROM hash("hercules") OVER father YIELD $$.character.name;
    =====================
    | $$.character.name |
    =====================
    | jupiter           |
    ---------------------

    cypher> MATCH (src:character{name:"prometheus"})-[r:father]->(dst:character)
          > RETURN dst.name
    ```

- Find the characters with age > 100

    ```bash
    nebula> XXX # not supported yet
    
    cypher> MATCH (src:character)
          > WHERE src.age > 100
          > RETURN src.name

    ```

- Find who are pluto's cohabitants

    ```bash
    nebula> GO FROM hash("pluto") OVER lives YIELD lives._dst AS place | GO FROM $-.place OVER lives REVERSELY WHERE \
    $$.character.name != "pluto" YIELD $$.character.name AS cohabitants;
    ===============
    | cohabitants |
    ===============
    | cerberus    |
    ---------------

    cypher> MATCH (src:character{name:"pluto"})-[r1:lives]->()<-[r2:lives]-(dst:character)
          > RETURN dst.name
    ```

-  Find pluto's brother and their live places?

    ```bash
    nebula> GO FROM hash("pluto") OVER brother YIELD brother._dst AS god | \
    GO FROM $-.god OVER lives YIELD $^.character.name AS Brother, $$.location.name AS Habitations;
    =========================
    | Brother | Habitations |
    =========================
    | jupiter | sky         |
    -------------------------
    | neptune | sea         |
    -------------------------

    cypher> MATCH (src:Character{name:"pluto"})-[r1:brother]->(bro:Character)-[r2:lives]->(dst)
          > RETURN bro.name, dst.name
    ```
