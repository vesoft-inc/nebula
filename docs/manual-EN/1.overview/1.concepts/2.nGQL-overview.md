# Nebula Graph Query Language (nGQL)

## About nGQL

`nGQL` is a declarative, textual query language like SQL, but for graphs. Unlike SQL, nGQL is all about expressing graph patterns. nGQL is a work in progress. We will add more features and further simplify the existing ones. There might be inconsistency between the syntax specs and implementation for the time being.

## Goals

- Easy to learn
- Easy to understand
- To focus on the online queries, also to provide the foundation for the offline computation

## Features

- Syntax is close to SQL, but not exactly the same (Easy to learn)
- Expandable
- Case insensitive
- Support basic graph traverse
- Support pattern match
- Support aggregation
- Support graph mutation
- Support distributed transaction (future release)
- Statement composition, but **NO** statement embedding (Easy to read)

## Terminology

- **Graph Space** : A physically isolated space for different graph
- **Tag** : A label associated with a list of properties
  - Each tag has a name (human readable string), and internally each tag will be assigned a 32-bit integer
  - Each tag associates with a list of properties, each property has a name and a type
  - There could be dependencies between tags. The dependency is a constrain, for instance, if tag S depends on tag T, then tag S cannot exist unless tag T exists
- **Vertex** : A Node in the graph
  - Each vertex has a unique 64-bit (signed integer) ID (**VID**)
  - Each vertex can associate with multiple **tags**
- **Edge** : A Link between two vertices
  - Each edge can be uniquely identified by a tuple **<src_vid, dst_vid, edge_type, rank
  - ***Edge type (ET)*** is a human readable string, internally it will be assigned a 32-bit integer. The edge type decides the property list (schema) on the edge
  - ***Edge rank*** is an immutable user-assigned 64-bit signed integer. It affects the edge order between two vertices. The edge with a higher rank value comes first. When not specified, the default rank value is zero.
  - Each edge can only be of one type
- **Path** : A ***non-forked*** connection with multiple vertices and edges between them.
  - The length of a path is the number of the edges on the path, which is one less than the number of vertices
  - A path can be represented by a list of vertices, edge types, and rank. An edge is a special path with length==1

```plain
 <vid, <edge_type, rank>, vid, ...>
```

## Language Specification At A Glance

> ***For most readers, You can skip this section if you are not familiar with BNF.***

### General

- The entire set of statements can be categorized into three classes: **query**, **mutation**, and **administration**
- Every statement can yield a data set as the result. Each data set contains a schema (column name and type) and multiple data rows

### Composition

- Statements could be composed in two ways:
  - Statements could be piped together using operator "**|**", much like the pipe in the shell scripts. The result yielded from the previous statement could be redirected to the next statement as input
  - More than one statements can be batched together, separated by "**;**". The result of the last statement (or a RETURN statement is executed) will be returned as the result of the batch

### Data Types

- Simple type: **vid**, **double**, **int**, **bool**, **string**, **timestamp**
 <!-- **float**,**path**, **year**, **month** (year/month), **date**, **datetime** -->
- **vid** : 64-bit signed integer, representing a vertex ID
- List of simple types, such as **integer[]**, **double[]**, **string[]**
- **Map**: A list of KV pairs. The key must be a **string**, the value must be the same type for the given map
- **Object** (future release??): A list of KV pairs. The key mush be a **string**, the value can be any simple type
- **Tuple List**: *This is only used for return values*. It's composed by both meta data and data (multiple rows). The meta data includes the column names and their types.

### Type Conversion

- A simple typed value can be implicitly converted into a list
- A list can be implicitly converted into a one-column tuple list
  - "<type\>\_list" can be used as the column name

### Common BNF

<simple\_type> ::= **vid** | **integer** | **double** | **float** | **bool** | **string** | **path** | **timestamp** | **year** | **month** | **date** | **datetime**

<composite_type> ::=

<type\> ::= <simple_type> | <composite\_type>

<vid\_list> ::= **vid** (, **vid**)\* | "{" **vid** (, **vid**)\* "}"

<label\> ::= \[:alpha\] ([:alnum:] | "\_")\*

<underscore\_label> ::= ("\_")* <label\>

<field\_name> ::= <label\>

<field\_def\_list> ::= <field\_def> (, <field\_def>)\*

<field\_def> ::= <field_name>:<type\>

<tuple\_list\_decl> ::= <tuple\_schema> ":" <tuple\_data>

<tuple\_schema> ::= <field\_def\_list>

<tuple\_data> ::= <tuple\> (, <tuple\>)\* | "{" <tuple\> (, <tuple\>)\* "}"

<tuple\> ::= "(" **VALUE** (, **VALUE**)\* ")"

<var\> ::= "$" <label\>

### Statements

#### Choose a graph space

Nebula supports multiple graph spaces. Data in different graph spaces are physically isolated. Before executing a query, a graph space needs to be selected using the following statement.

```ngql
USE <graphspace_name>
```

#### Return a data set

Simply return a single value or a data set.

```ngql
RETURN <return\_value\_decl>

<return\_value\_decl> ::= **vid** | <vid\_list> | <tuple\_list\_decl> | <var\>
```

#### Create a tag

The following statement defines a **new** tag.

```ngql
CREATE TAG <tag\_name> (<prop\_def\_list>)

<tag\_name> ::= <label\>
<prop\_def\_list> ::= <prop\_def>
<prop\_def> ::= <prop\_name>,<type\>
<prop\_name> ::= <label\>
```

#### Create an edge type

The following statement defines a **new** edge type

```ngql
CREATE EDGE <edge\_type\_name> (<prop\_def\_list>)

<edge\_type\_name> := <label\>
```

#### Insert vertices

The following statement inserts one or more vertices.

```ngql
INSERT **NO OVERWRITE <tag\_list>  <vertex\_list>

<tag\_list> ::= <tag\_name>(<prop\_list>) (, <tag\_name>(<prop\_list>))\*
<vertex\_list> ::= <vertex\_id>:(<prop\_value\_list>) (, <vertex\_id>:(<prop\_value\_list>))\*
<vertex\_id> ::= **vid**
<prop\_list> ::= <prop\_name> (, <prop\_name>)\*
<prop\_value\_list> ::= **VALUE** (, **VALUE**)\*
```

#### Insert edges

The following statement inserts one or more edges.

```ngql
INSERT NO OVERWRITE <edge\_type\_name> [(<prop\_list>)] VALUES (<edge\_value>)+

edge\_value ::= <vertex\_id> -> <vertex\_id> [@ <weight\>] : <prop\_value\_list>
```

#### Update a vertex

The following statement updates a vertex.

```ngql
UPDATE VERTEX  <vertex\_id>
SET\<update\_decl\>
WHERE <conditions\>
YIELD <field\_list>

<update\_decl> ::= <update\_form1> | <update\_form2>
<update\_form1> ::= <prop\_name> = <expression\> {,<prop\_name> = <expression\>}+
<update\_form2> ::= (<prop\_list>) = (<value\_list>) | (<prop\_list>) = <var\>
```

#### Update an edge

The following statement updates an edge.

```ngql
UPDATE EDGE<vertex\_id> -> <vertex\_id> [@<weight\>] OF <edge\_type>
SET <update\_decl>
WHERE <conditions\>
YIELD <field\_list>
```

#### Traverse the graph

Navigate from given vertices to their neighbors according to the given conditions. It returns either a list of vertex IDs, or a list of tuples.

```ngql
GO
<steps\_decl> STEPS
FROM <data\_set\_decl>
[OVER [REVERSELY] <edge\_type\_decl>
[WHERE <filter\_list>]
[YIELD <field\_list>]

<steps\_decl> ::= **integer** | **integer** TO **integer** | UPTO **integer**
<data\_set\_decl> ::= [data\_set] [[AS] <label\>]<br/>
<data\_set> ::= **vid** | <vid\_list> | <tuple\_list\_decl> | <var\><br/>
<edge\_type\_decl> ::= <edge\_type\_list> [AS <label\>]
<edge\_type\_list> ::= <edge\_type> {, <edge\_type>}\*
<edge\_type> ::= <label\>

<filter\_list> ::= <filter\> {AND | OR <filter\>}\*
<filter\> ::= <expression\> </span> | >= | < | <= | == | != <expression\> | <expression\> IN <value\_list\>
<field\_list> ::= <return\_field> {, <return\_field>}\*
<return\_field> ::= <expression\> [AS <label\>]
```

**WHERE** clause only applies to the results that are going to be returned. It will not be applied to the intermediate results (See the detail description of the STEP[S] clause)

When STEP[S] clause is skipped, it implies **one step**.

When going out for one step from the given vertex, all neighbors will be checked against the **WHERE** clause, only results satisfied the **WHERE** clause will be returned.

When going out for more than one step, **WHERE** clause will only be applied to the final results. It will not be applied to the intermediate results. Here is an example:

```ngql
GO 2 STEPS FROM me OVER friend WHERE birthday > "1988/1/1"
```

Obviously, you will probably guess the meaning of the query is to get all my fof (friend of friend) whose birthday is after 1988/1/1. You are absolutely right. We will not apply the filter to my friends (in the first step).

Here is another example:

```ngql
GO UPTO 3 STEPS FROM me OVER friend WHERE birthday > "1988/1/1/"
```

This query tries to find any friend of mine whose birthday is after 1988/1/1. If it finds at least one, it will return all the results. If it cannot find any, it will check my friends of friends to see if anyone's birthday is after 1988/1/1. It will return all the non-empty results, otherwise it will check my friends of friends of friends.

So, similarly, next query tries to find anyone whose birthday is after 1988/1/1 starting from my 3-hop friends, and finishing at my 5-hop friends.

```ngql
GO 3 TO 5 STEPS FROM me OVER friend WHERE birthday > "1988/1/1/"
```

#### Search

Following statements looks for vertices or edges that match certain conditions.

```ngql
FIND VERTEX
WHERE <filter\_list>
[YIELD <field\_list>]

FIND EDGE
WHERE <filter\_list>
[YIELD <field\_list>]
```

<!-- #### Pattern match
The following statement does a pattern match, and can return tuple list or paths

MATCH
<regular\_path\_expression>
[FROM <data\_set\_decl>]
[WHERE <filter\_list>]
[YIELD <field\_list>] -->

### Property Reference

It's common to refer a property in the statement, such as in **WHERE** clause and **YIELD** clause. In nGQL, the reference to a property is defined as:

```ngql
<property_ref> ::= <object\> "." <prop\_name>
<object\> ::= <alias\_name> | <alias\_with\_tag> | <var\>
<alias\_name> ::= <label\>
<alias\_with\_tag> ::= <alias\_name> '[' <tag\_name> "]"
```

<var\> always starts with `$`. There are two special variables: `$-` and `$$`.

`$-` refers to the input stream, while `$$` refers to the destination objects.

All property names start with a letter. There are a few system property names starting with "\_". All properties names starting with "\_" are reserved.

### Built-in properties

\_id : Vertex id
\_type : Edge type
\_src : Source ID of the edge
\_dst : Destination ID of the edge
\_rank : Edge rank number
