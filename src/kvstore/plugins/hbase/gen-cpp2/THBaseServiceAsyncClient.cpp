/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

#include "./gen-cpp2/THBaseServiceAsyncClient.h"

#include <folly/io/IOBuf.h>
#include <folly/io/IOBufQueue.h>
#include <thrift/lib/cpp/TApplicationException.h>
#include <thrift/lib/cpp/transport/THeader.h>
#include <thrift/lib/cpp2/protocol/BinaryProtocol.h>
#include <thrift/lib/cpp2/protocol/CompactProtocol.h>
#include <thrift/lib/cpp2/server/Cpp2ConnContext.h>
#include <thrift/lib/cpp2/GeneratedCodeHelper.h>
#include <thrift/lib/cpp2/GeneratedSerializationCodeHelper.h>

namespace apache { namespace hadoop { namespace hbase { namespace thrift2 { namespace cpp2 {
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, apache::thrift::protocol::T_STRING, std::string*>, apache::thrift::FieldData<2, apache::thrift::protocol::T_STRUCT,  ::apache::hadoop::hbase::thrift2::cpp2::TGet*>> THBaseService_exists_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, apache::thrift::protocol::T_BOOL, bool*>, apache::thrift::FieldData<1, apache::thrift::protocol::T_STRUCT,  ::apache::hadoop::hbase::thrift2::cpp2::TIOError>> THBaseService_exists_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, apache::thrift::protocol::T_STRING, std::string*>, apache::thrift::FieldData<2, apache::thrift::protocol::T_LIST, std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TGet>*>> THBaseService_existsAll_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, apache::thrift::protocol::T_LIST, std::vector<bool>*>, apache::thrift::FieldData<1, apache::thrift::protocol::T_STRUCT,  ::apache::hadoop::hbase::thrift2::cpp2::TIOError>> THBaseService_existsAll_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, apache::thrift::protocol::T_STRING, std::string*>, apache::thrift::FieldData<2, apache::thrift::protocol::T_STRUCT,  ::apache::hadoop::hbase::thrift2::cpp2::TGet*>> THBaseService_get_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, apache::thrift::protocol::T_STRUCT,  ::apache::hadoop::hbase::thrift2::cpp2::TResult*>, apache::thrift::FieldData<1, apache::thrift::protocol::T_STRUCT,  ::apache::hadoop::hbase::thrift2::cpp2::TIOError>> THBaseService_get_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, apache::thrift::protocol::T_STRING, std::string*>, apache::thrift::FieldData<2, apache::thrift::protocol::T_LIST, std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TGet>*>> THBaseService_getMultiple_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, apache::thrift::protocol::T_LIST, std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TResult>*>, apache::thrift::FieldData<1, apache::thrift::protocol::T_STRUCT,  ::apache::hadoop::hbase::thrift2::cpp2::TIOError>> THBaseService_getMultiple_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, apache::thrift::protocol::T_STRING, std::string*>, apache::thrift::FieldData<2, apache::thrift::protocol::T_STRUCT,  ::apache::hadoop::hbase::thrift2::cpp2::TPut*>> THBaseService_put_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<1, apache::thrift::protocol::T_STRUCT,  ::apache::hadoop::hbase::thrift2::cpp2::TIOError>> THBaseService_put_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, apache::thrift::protocol::T_STRING, std::string*>, apache::thrift::FieldData<2, apache::thrift::protocol::T_STRING, std::string*>, apache::thrift::FieldData<3, apache::thrift::protocol::T_STRING, std::string*>, apache::thrift::FieldData<4, apache::thrift::protocol::T_STRING, std::string*>, apache::thrift::FieldData<5, apache::thrift::protocol::T_STRING, std::string*>, apache::thrift::FieldData<6, apache::thrift::protocol::T_STRUCT,  ::apache::hadoop::hbase::thrift2::cpp2::TPut*>> THBaseService_checkAndPut_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, apache::thrift::protocol::T_BOOL, bool*>, apache::thrift::FieldData<1, apache::thrift::protocol::T_STRUCT,  ::apache::hadoop::hbase::thrift2::cpp2::TIOError>> THBaseService_checkAndPut_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, apache::thrift::protocol::T_STRING, std::string*>, apache::thrift::FieldData<2, apache::thrift::protocol::T_LIST, std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TPut>*>> THBaseService_putMultiple_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<1, apache::thrift::protocol::T_STRUCT,  ::apache::hadoop::hbase::thrift2::cpp2::TIOError>> THBaseService_putMultiple_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, apache::thrift::protocol::T_STRING, std::string*>, apache::thrift::FieldData<2, apache::thrift::protocol::T_STRUCT,  ::apache::hadoop::hbase::thrift2::cpp2::TDelete*>> THBaseService_deleteSingle_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<1, apache::thrift::protocol::T_STRUCT,  ::apache::hadoop::hbase::thrift2::cpp2::TIOError>> THBaseService_deleteSingle_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, apache::thrift::protocol::T_STRING, std::string*>, apache::thrift::FieldData<2, apache::thrift::protocol::T_LIST, std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TDelete>*>> THBaseService_deleteMultiple_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, apache::thrift::protocol::T_LIST, std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TDelete>*>, apache::thrift::FieldData<1, apache::thrift::protocol::T_STRUCT,  ::apache::hadoop::hbase::thrift2::cpp2::TIOError>> THBaseService_deleteMultiple_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, apache::thrift::protocol::T_STRING, std::string*>, apache::thrift::FieldData<2, apache::thrift::protocol::T_STRING, std::string*>, apache::thrift::FieldData<3, apache::thrift::protocol::T_STRING, std::string*>, apache::thrift::FieldData<4, apache::thrift::protocol::T_STRING, std::string*>, apache::thrift::FieldData<5, apache::thrift::protocol::T_STRING, std::string*>, apache::thrift::FieldData<6, apache::thrift::protocol::T_STRUCT,  ::apache::hadoop::hbase::thrift2::cpp2::TDelete*>> THBaseService_checkAndDelete_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, apache::thrift::protocol::T_BOOL, bool*>, apache::thrift::FieldData<1, apache::thrift::protocol::T_STRUCT,  ::apache::hadoop::hbase::thrift2::cpp2::TIOError>> THBaseService_checkAndDelete_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, apache::thrift::protocol::T_STRING, std::string*>, apache::thrift::FieldData<2, apache::thrift::protocol::T_STRUCT,  ::apache::hadoop::hbase::thrift2::cpp2::TIncrement*>> THBaseService_increment_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, apache::thrift::protocol::T_STRUCT,  ::apache::hadoop::hbase::thrift2::cpp2::TResult*>, apache::thrift::FieldData<1, apache::thrift::protocol::T_STRUCT,  ::apache::hadoop::hbase::thrift2::cpp2::TIOError>> THBaseService_increment_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, apache::thrift::protocol::T_STRING, std::string*>, apache::thrift::FieldData<2, apache::thrift::protocol::T_STRUCT,  ::apache::hadoop::hbase::thrift2::cpp2::TAppend*>> THBaseService_append_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, apache::thrift::protocol::T_STRUCT,  ::apache::hadoop::hbase::thrift2::cpp2::TResult*>, apache::thrift::FieldData<1, apache::thrift::protocol::T_STRUCT,  ::apache::hadoop::hbase::thrift2::cpp2::TIOError>> THBaseService_append_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, apache::thrift::protocol::T_STRING, std::string*>, apache::thrift::FieldData<2, apache::thrift::protocol::T_STRUCT,  ::apache::hadoop::hbase::thrift2::cpp2::TScan*>> THBaseService_openScanner_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, apache::thrift::protocol::T_I32, int32_t*>, apache::thrift::FieldData<1, apache::thrift::protocol::T_STRUCT,  ::apache::hadoop::hbase::thrift2::cpp2::TIOError>> THBaseService_openScanner_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, apache::thrift::protocol::T_I32, int32_t*>, apache::thrift::FieldData<2, apache::thrift::protocol::T_I32, int32_t*>> THBaseService_getScannerRows_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, apache::thrift::protocol::T_LIST, std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TResult>*>, apache::thrift::FieldData<1, apache::thrift::protocol::T_STRUCT,  ::apache::hadoop::hbase::thrift2::cpp2::TIOError>, apache::thrift::FieldData<2, apache::thrift::protocol::T_STRUCT,  ::apache::hadoop::hbase::thrift2::cpp2::TIllegalArgument>> THBaseService_getScannerRows_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, apache::thrift::protocol::T_I32, int32_t*>> THBaseService_closeScanner_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<1, apache::thrift::protocol::T_STRUCT,  ::apache::hadoop::hbase::thrift2::cpp2::TIOError>, apache::thrift::FieldData<2, apache::thrift::protocol::T_STRUCT,  ::apache::hadoop::hbase::thrift2::cpp2::TIllegalArgument>> THBaseService_closeScanner_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, apache::thrift::protocol::T_STRING, std::string*>, apache::thrift::FieldData<2, apache::thrift::protocol::T_STRUCT,  ::apache::hadoop::hbase::thrift2::cpp2::TRowMutations*>> THBaseService_mutateRow_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<1, apache::thrift::protocol::T_STRUCT,  ::apache::hadoop::hbase::thrift2::cpp2::TIOError>> THBaseService_mutateRow_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, apache::thrift::protocol::T_STRING, std::string*>, apache::thrift::FieldData<2, apache::thrift::protocol::T_STRUCT,  ::apache::hadoop::hbase::thrift2::cpp2::TScan*>, apache::thrift::FieldData<3, apache::thrift::protocol::T_I32, int32_t*>> THBaseService_getScannerResults_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, apache::thrift::protocol::T_LIST, std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TResult>*>, apache::thrift::FieldData<1, apache::thrift::protocol::T_STRUCT,  ::apache::hadoop::hbase::thrift2::cpp2::TIOError>> THBaseService_getScannerResults_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, apache::thrift::protocol::T_STRING, std::string*>, apache::thrift::FieldData<2, apache::thrift::protocol::T_STRING, std::string*>, apache::thrift::FieldData<3, apache::thrift::protocol::T_BOOL, bool*>> THBaseService_getRegionLocation_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, apache::thrift::protocol::T_STRUCT,  ::apache::hadoop::hbase::thrift2::cpp2::THRegionLocation*>, apache::thrift::FieldData<1, apache::thrift::protocol::T_STRUCT,  ::apache::hadoop::hbase::thrift2::cpp2::TIOError>> THBaseService_getRegionLocation_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, apache::thrift::protocol::T_STRING, std::string*>> THBaseService_getAllRegionLocations_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, apache::thrift::protocol::T_LIST, std::vector< ::apache::hadoop::hbase::thrift2::cpp2::THRegionLocation>*>, apache::thrift::FieldData<1, apache::thrift::protocol::T_STRUCT,  ::apache::hadoop::hbase::thrift2::cpp2::TIOError>> THBaseService_getAllRegionLocations_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, apache::thrift::protocol::T_STRING, std::string*>, apache::thrift::FieldData<2, apache::thrift::protocol::T_STRING, std::string*>, apache::thrift::FieldData<3, apache::thrift::protocol::T_STRING, std::string*>, apache::thrift::FieldData<4, apache::thrift::protocol::T_STRING, std::string*>, apache::thrift::FieldData<5, apache::thrift::protocol::T_I32,  ::apache::hadoop::hbase::thrift2::cpp2::TCompareOp*>, apache::thrift::FieldData<6, apache::thrift::protocol::T_STRING, std::string*>, apache::thrift::FieldData<7, apache::thrift::protocol::T_STRUCT,  ::apache::hadoop::hbase::thrift2::cpp2::TRowMutations*>> THBaseService_checkAndMutate_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, apache::thrift::protocol::T_BOOL, bool*>, apache::thrift::FieldData<1, apache::thrift::protocol::T_STRUCT,  ::apache::hadoop::hbase::thrift2::cpp2::TIOError>> THBaseService_checkAndMutate_presult;

template <typename Protocol_>
void THBaseServiceAsyncClient::existsT(Protocol_* prot, bool useSync, apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const std::string& table, const  ::apache::hadoop::hbase::thrift2::cpp2::TGet& tget) {
  struct HeaderAndConnContext {
    HeaderAndConnContext() : header(apache::thrift::transport::THeader::ALLOW_BIG_FRAMES) {}

    apache::thrift::transport::THeader header;
    apache::thrift::Cpp2ConnContext connContext;
  };
  auto headerAndConnContext = std::make_shared<HeaderAndConnContext>();
  std::shared_ptr<apache::thrift::transport::THeader> header(headerAndConnContext, &headerAndConnContext->header);
  header->setProtocolId(getChannel()->getProtocolId());
  header->setHeaders(rpcOptions.releaseWriteHeaders());
  headerAndConnContext->connContext.setRequestHeader(header.get());
  std::unique_ptr<apache::thrift::ContextStack> ctx = this->getContextStack(this->getServiceName(), "THBaseService.exists", &headerAndConnContext->connContext);
  THBaseService_exists_pargs args;
  args.get<0>().value = const_cast<std::string*>(&table);
  args.get<1>().value = const_cast< ::apache::hadoop::hbase::thrift2::cpp2::TGet*>(&tget);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  apache::thrift::clientSendT<Protocol_>(prot, rpcOptions, std::move(callback), std::move(ctx), header, channel_.get(), "exists", writer, sizer, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, useSync);
  headerAndConnContext->connContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void THBaseServiceAsyncClient::existsAllT(Protocol_* prot, bool useSync, apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const std::string& table, const std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TGet>& tgets) {
  struct HeaderAndConnContext {
    HeaderAndConnContext() : header(apache::thrift::transport::THeader::ALLOW_BIG_FRAMES) {}

    apache::thrift::transport::THeader header;
    apache::thrift::Cpp2ConnContext connContext;
  };
  auto headerAndConnContext = std::make_shared<HeaderAndConnContext>();
  std::shared_ptr<apache::thrift::transport::THeader> header(headerAndConnContext, &headerAndConnContext->header);
  header->setProtocolId(getChannel()->getProtocolId());
  header->setHeaders(rpcOptions.releaseWriteHeaders());
  headerAndConnContext->connContext.setRequestHeader(header.get());
  std::unique_ptr<apache::thrift::ContextStack> ctx = this->getContextStack(this->getServiceName(), "THBaseService.existsAll", &headerAndConnContext->connContext);
  THBaseService_existsAll_pargs args;
  args.get<0>().value = const_cast<std::string*>(&table);
  args.get<1>().value = const_cast<std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TGet>*>(&tgets);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  apache::thrift::clientSendT<Protocol_>(prot, rpcOptions, std::move(callback), std::move(ctx), header, channel_.get(), "existsAll", writer, sizer, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, useSync);
  headerAndConnContext->connContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void THBaseServiceAsyncClient::getT(Protocol_* prot, bool useSync, apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const std::string& table, const  ::apache::hadoop::hbase::thrift2::cpp2::TGet& tget) {
  struct HeaderAndConnContext {
    HeaderAndConnContext() : header(apache::thrift::transport::THeader::ALLOW_BIG_FRAMES) {}

    apache::thrift::transport::THeader header;
    apache::thrift::Cpp2ConnContext connContext;
  };
  auto headerAndConnContext = std::make_shared<HeaderAndConnContext>();
  std::shared_ptr<apache::thrift::transport::THeader> header(headerAndConnContext, &headerAndConnContext->header);
  header->setProtocolId(getChannel()->getProtocolId());
  header->setHeaders(rpcOptions.releaseWriteHeaders());
  headerAndConnContext->connContext.setRequestHeader(header.get());
  std::unique_ptr<apache::thrift::ContextStack> ctx = this->getContextStack(this->getServiceName(), "THBaseService.get", &headerAndConnContext->connContext);
  THBaseService_get_pargs args;
  args.get<0>().value = const_cast<std::string*>(&table);
  args.get<1>().value = const_cast< ::apache::hadoop::hbase::thrift2::cpp2::TGet*>(&tget);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  apache::thrift::clientSendT<Protocol_>(prot, rpcOptions, std::move(callback), std::move(ctx), header, channel_.get(), "get", writer, sizer, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, useSync);
  headerAndConnContext->connContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void THBaseServiceAsyncClient::getMultipleT(Protocol_* prot, bool useSync, apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const std::string& table, const std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TGet>& tgets) {
  struct HeaderAndConnContext {
    HeaderAndConnContext() : header(apache::thrift::transport::THeader::ALLOW_BIG_FRAMES) {}

    apache::thrift::transport::THeader header;
    apache::thrift::Cpp2ConnContext connContext;
  };
  auto headerAndConnContext = std::make_shared<HeaderAndConnContext>();
  std::shared_ptr<apache::thrift::transport::THeader> header(headerAndConnContext, &headerAndConnContext->header);
  header->setProtocolId(getChannel()->getProtocolId());
  header->setHeaders(rpcOptions.releaseWriteHeaders());
  headerAndConnContext->connContext.setRequestHeader(header.get());
  std::unique_ptr<apache::thrift::ContextStack> ctx = this->getContextStack(this->getServiceName(), "THBaseService.getMultiple", &headerAndConnContext->connContext);
  THBaseService_getMultiple_pargs args;
  args.get<0>().value = const_cast<std::string*>(&table);
  args.get<1>().value = const_cast<std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TGet>*>(&tgets);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  apache::thrift::clientSendT<Protocol_>(prot, rpcOptions, std::move(callback), std::move(ctx), header, channel_.get(), "getMultiple", writer, sizer, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, useSync);
  headerAndConnContext->connContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void THBaseServiceAsyncClient::putT(Protocol_* prot, bool useSync, apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const std::string& table, const  ::apache::hadoop::hbase::thrift2::cpp2::TPut& tput) {
  struct HeaderAndConnContext {
    HeaderAndConnContext() : header(apache::thrift::transport::THeader::ALLOW_BIG_FRAMES) {}

    apache::thrift::transport::THeader header;
    apache::thrift::Cpp2ConnContext connContext;
  };
  auto headerAndConnContext = std::make_shared<HeaderAndConnContext>();
  std::shared_ptr<apache::thrift::transport::THeader> header(headerAndConnContext, &headerAndConnContext->header);
  header->setProtocolId(getChannel()->getProtocolId());
  header->setHeaders(rpcOptions.releaseWriteHeaders());
  headerAndConnContext->connContext.setRequestHeader(header.get());
  std::unique_ptr<apache::thrift::ContextStack> ctx = this->getContextStack(this->getServiceName(), "THBaseService.put", &headerAndConnContext->connContext);
  THBaseService_put_pargs args;
  args.get<0>().value = const_cast<std::string*>(&table);
  args.get<1>().value = const_cast< ::apache::hadoop::hbase::thrift2::cpp2::TPut*>(&tput);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  apache::thrift::clientSendT<Protocol_>(prot, rpcOptions, std::move(callback), std::move(ctx), header, channel_.get(), "put", writer, sizer, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, useSync);
  headerAndConnContext->connContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void THBaseServiceAsyncClient::checkAndPutT(Protocol_* prot, bool useSync, apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const std::string& table, const std::string& row, const std::string& family, const std::string& qualifier, const std::string& value, const  ::apache::hadoop::hbase::thrift2::cpp2::TPut& tput) {
  struct HeaderAndConnContext {
    HeaderAndConnContext() : header(apache::thrift::transport::THeader::ALLOW_BIG_FRAMES) {}

    apache::thrift::transport::THeader header;
    apache::thrift::Cpp2ConnContext connContext;
  };
  auto headerAndConnContext = std::make_shared<HeaderAndConnContext>();
  std::shared_ptr<apache::thrift::transport::THeader> header(headerAndConnContext, &headerAndConnContext->header);
  header->setProtocolId(getChannel()->getProtocolId());
  header->setHeaders(rpcOptions.releaseWriteHeaders());
  headerAndConnContext->connContext.setRequestHeader(header.get());
  std::unique_ptr<apache::thrift::ContextStack> ctx = this->getContextStack(this->getServiceName(), "THBaseService.checkAndPut", &headerAndConnContext->connContext);
  THBaseService_checkAndPut_pargs args;
  args.get<0>().value = const_cast<std::string*>(&table);
  args.get<1>().value = const_cast<std::string*>(&row);
  args.get<2>().value = const_cast<std::string*>(&family);
  args.get<3>().value = const_cast<std::string*>(&qualifier);
  args.get<4>().value = const_cast<std::string*>(&value);
  args.get<5>().value = const_cast< ::apache::hadoop::hbase::thrift2::cpp2::TPut*>(&tput);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  apache::thrift::clientSendT<Protocol_>(prot, rpcOptions, std::move(callback), std::move(ctx), header, channel_.get(), "checkAndPut", writer, sizer, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, useSync);
  headerAndConnContext->connContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void THBaseServiceAsyncClient::putMultipleT(Protocol_* prot, bool useSync, apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const std::string& table, const std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TPut>& tputs) {
  struct HeaderAndConnContext {
    HeaderAndConnContext() : header(apache::thrift::transport::THeader::ALLOW_BIG_FRAMES) {}

    apache::thrift::transport::THeader header;
    apache::thrift::Cpp2ConnContext connContext;
  };
  auto headerAndConnContext = std::make_shared<HeaderAndConnContext>();
  std::shared_ptr<apache::thrift::transport::THeader> header(headerAndConnContext, &headerAndConnContext->header);
  header->setProtocolId(getChannel()->getProtocolId());
  header->setHeaders(rpcOptions.releaseWriteHeaders());
  headerAndConnContext->connContext.setRequestHeader(header.get());
  std::unique_ptr<apache::thrift::ContextStack> ctx = this->getContextStack(this->getServiceName(), "THBaseService.putMultiple", &headerAndConnContext->connContext);
  THBaseService_putMultiple_pargs args;
  args.get<0>().value = const_cast<std::string*>(&table);
  args.get<1>().value = const_cast<std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TPut>*>(&tputs);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  apache::thrift::clientSendT<Protocol_>(prot, rpcOptions, std::move(callback), std::move(ctx), header, channel_.get(), "putMultiple", writer, sizer, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, useSync);
  headerAndConnContext->connContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void THBaseServiceAsyncClient::deleteSingleT(Protocol_* prot, bool useSync, apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const std::string& table, const  ::apache::hadoop::hbase::thrift2::cpp2::TDelete& tdelete) {
  struct HeaderAndConnContext {
    HeaderAndConnContext() : header(apache::thrift::transport::THeader::ALLOW_BIG_FRAMES) {}

    apache::thrift::transport::THeader header;
    apache::thrift::Cpp2ConnContext connContext;
  };
  auto headerAndConnContext = std::make_shared<HeaderAndConnContext>();
  std::shared_ptr<apache::thrift::transport::THeader> header(headerAndConnContext, &headerAndConnContext->header);
  header->setProtocolId(getChannel()->getProtocolId());
  header->setHeaders(rpcOptions.releaseWriteHeaders());
  headerAndConnContext->connContext.setRequestHeader(header.get());
  std::unique_ptr<apache::thrift::ContextStack> ctx = this->getContextStack(this->getServiceName(), "THBaseService.deleteSingle", &headerAndConnContext->connContext);
  THBaseService_deleteSingle_pargs args;
  args.get<0>().value = const_cast<std::string*>(&table);
  args.get<1>().value = const_cast< ::apache::hadoop::hbase::thrift2::cpp2::TDelete*>(&tdelete);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  apache::thrift::clientSendT<Protocol_>(prot, rpcOptions, std::move(callback), std::move(ctx), header, channel_.get(), "deleteSingle", writer, sizer, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, useSync);
  headerAndConnContext->connContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void THBaseServiceAsyncClient::deleteMultipleT(Protocol_* prot, bool useSync, apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const std::string& table, const std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TDelete>& tdeletes) {
  struct HeaderAndConnContext {
    HeaderAndConnContext() : header(apache::thrift::transport::THeader::ALLOW_BIG_FRAMES) {}

    apache::thrift::transport::THeader header;
    apache::thrift::Cpp2ConnContext connContext;
  };
  auto headerAndConnContext = std::make_shared<HeaderAndConnContext>();
  std::shared_ptr<apache::thrift::transport::THeader> header(headerAndConnContext, &headerAndConnContext->header);
  header->setProtocolId(getChannel()->getProtocolId());
  header->setHeaders(rpcOptions.releaseWriteHeaders());
  headerAndConnContext->connContext.setRequestHeader(header.get());
  std::unique_ptr<apache::thrift::ContextStack> ctx = this->getContextStack(this->getServiceName(), "THBaseService.deleteMultiple", &headerAndConnContext->connContext);
  THBaseService_deleteMultiple_pargs args;
  args.get<0>().value = const_cast<std::string*>(&table);
  args.get<1>().value = const_cast<std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TDelete>*>(&tdeletes);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  apache::thrift::clientSendT<Protocol_>(prot, rpcOptions, std::move(callback), std::move(ctx), header, channel_.get(), "deleteMultiple", writer, sizer, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, useSync);
  headerAndConnContext->connContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void THBaseServiceAsyncClient::checkAndDeleteT(Protocol_* prot, bool useSync, apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const std::string& table, const std::string& row, const std::string& family, const std::string& qualifier, const std::string& value, const  ::apache::hadoop::hbase::thrift2::cpp2::TDelete& tdelete) {
  struct HeaderAndConnContext {
    HeaderAndConnContext() : header(apache::thrift::transport::THeader::ALLOW_BIG_FRAMES) {}

    apache::thrift::transport::THeader header;
    apache::thrift::Cpp2ConnContext connContext;
  };
  auto headerAndConnContext = std::make_shared<HeaderAndConnContext>();
  std::shared_ptr<apache::thrift::transport::THeader> header(headerAndConnContext, &headerAndConnContext->header);
  header->setProtocolId(getChannel()->getProtocolId());
  header->setHeaders(rpcOptions.releaseWriteHeaders());
  headerAndConnContext->connContext.setRequestHeader(header.get());
  std::unique_ptr<apache::thrift::ContextStack> ctx = this->getContextStack(this->getServiceName(), "THBaseService.checkAndDelete", &headerAndConnContext->connContext);
  THBaseService_checkAndDelete_pargs args;
  args.get<0>().value = const_cast<std::string*>(&table);
  args.get<1>().value = const_cast<std::string*>(&row);
  args.get<2>().value = const_cast<std::string*>(&family);
  args.get<3>().value = const_cast<std::string*>(&qualifier);
  args.get<4>().value = const_cast<std::string*>(&value);
  args.get<5>().value = const_cast< ::apache::hadoop::hbase::thrift2::cpp2::TDelete*>(&tdelete);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  apache::thrift::clientSendT<Protocol_>(prot, rpcOptions, std::move(callback), std::move(ctx), header, channel_.get(), "checkAndDelete", writer, sizer, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, useSync);
  headerAndConnContext->connContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void THBaseServiceAsyncClient::incrementT(Protocol_* prot, bool useSync, apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const std::string& table, const  ::apache::hadoop::hbase::thrift2::cpp2::TIncrement& tincrement) {
  struct HeaderAndConnContext {
    HeaderAndConnContext() : header(apache::thrift::transport::THeader::ALLOW_BIG_FRAMES) {}

    apache::thrift::transport::THeader header;
    apache::thrift::Cpp2ConnContext connContext;
  };
  auto headerAndConnContext = std::make_shared<HeaderAndConnContext>();
  std::shared_ptr<apache::thrift::transport::THeader> header(headerAndConnContext, &headerAndConnContext->header);
  header->setProtocolId(getChannel()->getProtocolId());
  header->setHeaders(rpcOptions.releaseWriteHeaders());
  headerAndConnContext->connContext.setRequestHeader(header.get());
  std::unique_ptr<apache::thrift::ContextStack> ctx = this->getContextStack(this->getServiceName(), "THBaseService.increment", &headerAndConnContext->connContext);
  THBaseService_increment_pargs args;
  args.get<0>().value = const_cast<std::string*>(&table);
  args.get<1>().value = const_cast< ::apache::hadoop::hbase::thrift2::cpp2::TIncrement*>(&tincrement);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  apache::thrift::clientSendT<Protocol_>(prot, rpcOptions, std::move(callback), std::move(ctx), header, channel_.get(), "increment", writer, sizer, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, useSync);
  headerAndConnContext->connContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void THBaseServiceAsyncClient::appendT(Protocol_* prot, bool useSync, apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const std::string& table, const  ::apache::hadoop::hbase::thrift2::cpp2::TAppend& tappend) {
  struct HeaderAndConnContext {
    HeaderAndConnContext() : header(apache::thrift::transport::THeader::ALLOW_BIG_FRAMES) {}

    apache::thrift::transport::THeader header;
    apache::thrift::Cpp2ConnContext connContext;
  };
  auto headerAndConnContext = std::make_shared<HeaderAndConnContext>();
  std::shared_ptr<apache::thrift::transport::THeader> header(headerAndConnContext, &headerAndConnContext->header);
  header->setProtocolId(getChannel()->getProtocolId());
  header->setHeaders(rpcOptions.releaseWriteHeaders());
  headerAndConnContext->connContext.setRequestHeader(header.get());
  std::unique_ptr<apache::thrift::ContextStack> ctx = this->getContextStack(this->getServiceName(), "THBaseService.append", &headerAndConnContext->connContext);
  THBaseService_append_pargs args;
  args.get<0>().value = const_cast<std::string*>(&table);
  args.get<1>().value = const_cast< ::apache::hadoop::hbase::thrift2::cpp2::TAppend*>(&tappend);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  apache::thrift::clientSendT<Protocol_>(prot, rpcOptions, std::move(callback), std::move(ctx), header, channel_.get(), "append", writer, sizer, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, useSync);
  headerAndConnContext->connContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void THBaseServiceAsyncClient::openScannerT(Protocol_* prot, bool useSync, apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const std::string& table, const  ::apache::hadoop::hbase::thrift2::cpp2::TScan& tscan) {
  struct HeaderAndConnContext {
    HeaderAndConnContext() : header(apache::thrift::transport::THeader::ALLOW_BIG_FRAMES) {}

    apache::thrift::transport::THeader header;
    apache::thrift::Cpp2ConnContext connContext;
  };
  auto headerAndConnContext = std::make_shared<HeaderAndConnContext>();
  std::shared_ptr<apache::thrift::transport::THeader> header(headerAndConnContext, &headerAndConnContext->header);
  header->setProtocolId(getChannel()->getProtocolId());
  header->setHeaders(rpcOptions.releaseWriteHeaders());
  headerAndConnContext->connContext.setRequestHeader(header.get());
  std::unique_ptr<apache::thrift::ContextStack> ctx = this->getContextStack(this->getServiceName(), "THBaseService.openScanner", &headerAndConnContext->connContext);
  THBaseService_openScanner_pargs args;
  args.get<0>().value = const_cast<std::string*>(&table);
  args.get<1>().value = const_cast< ::apache::hadoop::hbase::thrift2::cpp2::TScan*>(&tscan);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  apache::thrift::clientSendT<Protocol_>(prot, rpcOptions, std::move(callback), std::move(ctx), header, channel_.get(), "openScanner", writer, sizer, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, useSync);
  headerAndConnContext->connContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void THBaseServiceAsyncClient::getScannerRowsT(Protocol_* prot, bool useSync, apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, int32_t scannerId, int32_t numRows) {
  struct HeaderAndConnContext {
    HeaderAndConnContext() : header(apache::thrift::transport::THeader::ALLOW_BIG_FRAMES) {}

    apache::thrift::transport::THeader header;
    apache::thrift::Cpp2ConnContext connContext;
  };
  auto headerAndConnContext = std::make_shared<HeaderAndConnContext>();
  std::shared_ptr<apache::thrift::transport::THeader> header(headerAndConnContext, &headerAndConnContext->header);
  header->setProtocolId(getChannel()->getProtocolId());
  header->setHeaders(rpcOptions.releaseWriteHeaders());
  headerAndConnContext->connContext.setRequestHeader(header.get());
  std::unique_ptr<apache::thrift::ContextStack> ctx = this->getContextStack(this->getServiceName(), "THBaseService.getScannerRows", &headerAndConnContext->connContext);
  THBaseService_getScannerRows_pargs args;
  args.get<0>().value = &scannerId;
  args.get<1>().value = &numRows;
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  apache::thrift::clientSendT<Protocol_>(prot, rpcOptions, std::move(callback), std::move(ctx), header, channel_.get(), "getScannerRows", writer, sizer, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, useSync);
  headerAndConnContext->connContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void THBaseServiceAsyncClient::closeScannerT(Protocol_* prot, bool useSync, apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, int32_t scannerId) {
  struct HeaderAndConnContext {
    HeaderAndConnContext() : header(apache::thrift::transport::THeader::ALLOW_BIG_FRAMES) {}

    apache::thrift::transport::THeader header;
    apache::thrift::Cpp2ConnContext connContext;
  };
  auto headerAndConnContext = std::make_shared<HeaderAndConnContext>();
  std::shared_ptr<apache::thrift::transport::THeader> header(headerAndConnContext, &headerAndConnContext->header);
  header->setProtocolId(getChannel()->getProtocolId());
  header->setHeaders(rpcOptions.releaseWriteHeaders());
  headerAndConnContext->connContext.setRequestHeader(header.get());
  std::unique_ptr<apache::thrift::ContextStack> ctx = this->getContextStack(this->getServiceName(), "THBaseService.closeScanner", &headerAndConnContext->connContext);
  THBaseService_closeScanner_pargs args;
  args.get<0>().value = &scannerId;
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  apache::thrift::clientSendT<Protocol_>(prot, rpcOptions, std::move(callback), std::move(ctx), header, channel_.get(), "closeScanner", writer, sizer, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, useSync);
  headerAndConnContext->connContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void THBaseServiceAsyncClient::mutateRowT(Protocol_* prot, bool useSync, apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const std::string& table, const  ::apache::hadoop::hbase::thrift2::cpp2::TRowMutations& trowMutations) {
  struct HeaderAndConnContext {
    HeaderAndConnContext() : header(apache::thrift::transport::THeader::ALLOW_BIG_FRAMES) {}

    apache::thrift::transport::THeader header;
    apache::thrift::Cpp2ConnContext connContext;
  };
  auto headerAndConnContext = std::make_shared<HeaderAndConnContext>();
  std::shared_ptr<apache::thrift::transport::THeader> header(headerAndConnContext, &headerAndConnContext->header);
  header->setProtocolId(getChannel()->getProtocolId());
  header->setHeaders(rpcOptions.releaseWriteHeaders());
  headerAndConnContext->connContext.setRequestHeader(header.get());
  std::unique_ptr<apache::thrift::ContextStack> ctx = this->getContextStack(this->getServiceName(), "THBaseService.mutateRow", &headerAndConnContext->connContext);
  THBaseService_mutateRow_pargs args;
  args.get<0>().value = const_cast<std::string*>(&table);
  args.get<1>().value = const_cast< ::apache::hadoop::hbase::thrift2::cpp2::TRowMutations*>(&trowMutations);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  apache::thrift::clientSendT<Protocol_>(prot, rpcOptions, std::move(callback), std::move(ctx), header, channel_.get(), "mutateRow", writer, sizer, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, useSync);
  headerAndConnContext->connContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void THBaseServiceAsyncClient::getScannerResultsT(Protocol_* prot, bool useSync, apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const std::string& table, const  ::apache::hadoop::hbase::thrift2::cpp2::TScan& tscan, int32_t numRows) {
  struct HeaderAndConnContext {
    HeaderAndConnContext() : header(apache::thrift::transport::THeader::ALLOW_BIG_FRAMES) {}

    apache::thrift::transport::THeader header;
    apache::thrift::Cpp2ConnContext connContext;
  };
  auto headerAndConnContext = std::make_shared<HeaderAndConnContext>();
  std::shared_ptr<apache::thrift::transport::THeader> header(headerAndConnContext, &headerAndConnContext->header);
  header->setProtocolId(getChannel()->getProtocolId());
  header->setHeaders(rpcOptions.releaseWriteHeaders());
  headerAndConnContext->connContext.setRequestHeader(header.get());
  std::unique_ptr<apache::thrift::ContextStack> ctx = this->getContextStack(this->getServiceName(), "THBaseService.getScannerResults", &headerAndConnContext->connContext);
  THBaseService_getScannerResults_pargs args;
  args.get<0>().value = const_cast<std::string*>(&table);
  args.get<1>().value = const_cast< ::apache::hadoop::hbase::thrift2::cpp2::TScan*>(&tscan);
  args.get<2>().value = &numRows;
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  apache::thrift::clientSendT<Protocol_>(prot, rpcOptions, std::move(callback), std::move(ctx), header, channel_.get(), "getScannerResults", writer, sizer, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, useSync);
  headerAndConnContext->connContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void THBaseServiceAsyncClient::getRegionLocationT(Protocol_* prot, bool useSync, apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const std::string& table, const std::string& row, bool reload) {
  struct HeaderAndConnContext {
    HeaderAndConnContext() : header(apache::thrift::transport::THeader::ALLOW_BIG_FRAMES) {}

    apache::thrift::transport::THeader header;
    apache::thrift::Cpp2ConnContext connContext;
  };
  auto headerAndConnContext = std::make_shared<HeaderAndConnContext>();
  std::shared_ptr<apache::thrift::transport::THeader> header(headerAndConnContext, &headerAndConnContext->header);
  header->setProtocolId(getChannel()->getProtocolId());
  header->setHeaders(rpcOptions.releaseWriteHeaders());
  headerAndConnContext->connContext.setRequestHeader(header.get());
  std::unique_ptr<apache::thrift::ContextStack> ctx = this->getContextStack(this->getServiceName(), "THBaseService.getRegionLocation", &headerAndConnContext->connContext);
  THBaseService_getRegionLocation_pargs args;
  args.get<0>().value = const_cast<std::string*>(&table);
  args.get<1>().value = const_cast<std::string*>(&row);
  args.get<2>().value = &reload;
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  apache::thrift::clientSendT<Protocol_>(prot, rpcOptions, std::move(callback), std::move(ctx), header, channel_.get(), "getRegionLocation", writer, sizer, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, useSync);
  headerAndConnContext->connContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void THBaseServiceAsyncClient::getAllRegionLocationsT(Protocol_* prot, bool useSync, apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const std::string& table) {
  struct HeaderAndConnContext {
    HeaderAndConnContext() : header(apache::thrift::transport::THeader::ALLOW_BIG_FRAMES) {}

    apache::thrift::transport::THeader header;
    apache::thrift::Cpp2ConnContext connContext;
  };
  auto headerAndConnContext = std::make_shared<HeaderAndConnContext>();
  std::shared_ptr<apache::thrift::transport::THeader> header(headerAndConnContext, &headerAndConnContext->header);
  header->setProtocolId(getChannel()->getProtocolId());
  header->setHeaders(rpcOptions.releaseWriteHeaders());
  headerAndConnContext->connContext.setRequestHeader(header.get());
  std::unique_ptr<apache::thrift::ContextStack> ctx = this->getContextStack(this->getServiceName(), "THBaseService.getAllRegionLocations", &headerAndConnContext->connContext);
  THBaseService_getAllRegionLocations_pargs args;
  args.get<0>().value = const_cast<std::string*>(&table);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  apache::thrift::clientSendT<Protocol_>(prot, rpcOptions, std::move(callback), std::move(ctx), header, channel_.get(), "getAllRegionLocations", writer, sizer, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, useSync);
  headerAndConnContext->connContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void THBaseServiceAsyncClient::checkAndMutateT(Protocol_* prot, bool useSync, apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const std::string& table, const std::string& row, const std::string& family, const std::string& qualifier,  ::apache::hadoop::hbase::thrift2::cpp2::TCompareOp compareOp, const std::string& value, const  ::apache::hadoop::hbase::thrift2::cpp2::TRowMutations& rowMutations) {
  struct HeaderAndConnContext {
    HeaderAndConnContext() : header(apache::thrift::transport::THeader::ALLOW_BIG_FRAMES) {}

    apache::thrift::transport::THeader header;
    apache::thrift::Cpp2ConnContext connContext;
  };
  auto headerAndConnContext = std::make_shared<HeaderAndConnContext>();
  std::shared_ptr<apache::thrift::transport::THeader> header(headerAndConnContext, &headerAndConnContext->header);
  header->setProtocolId(getChannel()->getProtocolId());
  header->setHeaders(rpcOptions.releaseWriteHeaders());
  headerAndConnContext->connContext.setRequestHeader(header.get());
  std::unique_ptr<apache::thrift::ContextStack> ctx = this->getContextStack(this->getServiceName(), "THBaseService.checkAndMutate", &headerAndConnContext->connContext);
  THBaseService_checkAndMutate_pargs args;
  args.get<0>().value = const_cast<std::string*>(&table);
  args.get<1>().value = const_cast<std::string*>(&row);
  args.get<2>().value = const_cast<std::string*>(&family);
  args.get<3>().value = const_cast<std::string*>(&qualifier);
  args.get<4>().value = &compareOp;
  args.get<5>().value = const_cast<std::string*>(&value);
  args.get<6>().value = const_cast< ::apache::hadoop::hbase::thrift2::cpp2::TRowMutations*>(&rowMutations);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  apache::thrift::clientSendT<Protocol_>(prot, rpcOptions, std::move(callback), std::move(ctx), header, channel_.get(), "checkAndMutate", writer, sizer, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, useSync);
  headerAndConnContext->connContext.setRequestHeader(nullptr);
}



void THBaseServiceAsyncClient::exists(std::unique_ptr<apache::thrift::RequestCallback> callback, const std::string& table, const  ::apache::hadoop::hbase::thrift2::cpp2::TGet& tget) {
  ::apache::thrift::RpcOptions rpcOptions;
  existsImpl(false, rpcOptions, std::move(callback), table, tget);
}

void THBaseServiceAsyncClient::exists(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const std::string& table, const  ::apache::hadoop::hbase::thrift2::cpp2::TGet& tget) {
  existsImpl(false, rpcOptions, std::move(callback), table, tget);
}

void THBaseServiceAsyncClient::existsImpl(bool useSync, apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const std::string& table, const  ::apache::hadoop::hbase::thrift2::cpp2::TGet& tget) {
  switch(getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      existsT(&writer, useSync, rpcOptions, std::move(callback), table, tget);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      existsT(&writer, useSync, rpcOptions, std::move(callback), table, tget);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

bool THBaseServiceAsyncClient::sync_exists(const std::string& table, const  ::apache::hadoop::hbase::thrift2::cpp2::TGet& tget) {
  ::apache::thrift::RpcOptions rpcOptions;
  return sync_exists(rpcOptions, table, tget);
}

bool THBaseServiceAsyncClient::sync_exists(apache::thrift::RpcOptions& rpcOptions, const std::string& table, const  ::apache::hadoop::hbase::thrift2::cpp2::TGet& tget) {
  apache::thrift::ClientReceiveState _returnState;
  auto callback = std::make_unique<apache::thrift::ClientSyncCallback>(
      &_returnState, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE);
  existsImpl(true, rpcOptions, std::move(callback), table, tget);
  SCOPE_EXIT {
    if (_returnState.header() && !_returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(_returnState.header()->releaseHeaders());
    }
  };
  if (!_returnState.buf()) {
    assert(!!_returnState.exception());
    _returnState.exception().throw_exception();
  }
  return recv_exists(_returnState);
}

folly::Future<bool> THBaseServiceAsyncClient::future_exists(const std::string& table, const  ::apache::hadoop::hbase::thrift2::cpp2::TGet& tget) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_exists(rpcOptions, table, tget);
}

folly::SemiFuture<bool> THBaseServiceAsyncClient::semifuture_exists(const std::string& table, const  ::apache::hadoop::hbase::thrift2::cpp2::TGet& tget) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_exists(rpcOptions, table, tget);
}

folly::Future<bool> THBaseServiceAsyncClient::future_exists(apache::thrift::RpcOptions& rpcOptions, const std::string& table, const  ::apache::hadoop::hbase::thrift2::cpp2::TGet& tget) {
  folly::Promise<bool> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback<bool>>(std::move(_promise), recv_wrapped_exists, channel_);
  exists(rpcOptions, std::move(callback), table, tget);
  return _future;
}

folly::SemiFuture<bool> THBaseServiceAsyncClient::semifuture_exists(apache::thrift::RpcOptions& rpcOptions, const std::string& table, const  ::apache::hadoop::hbase::thrift2::cpp2::TGet& tget) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_exists, channel_);
  auto callback = std::move(callbackAndFuture.first);
  exists(rpcOptions, std::move(callback), table, tget);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair<bool, std::unique_ptr<apache::thrift::transport::THeader>>> THBaseServiceAsyncClient::header_future_exists(apache::thrift::RpcOptions& rpcOptions, const std::string& table, const  ::apache::hadoop::hbase::thrift2::cpp2::TGet& tget) {
  folly::Promise<std::pair<bool, std::unique_ptr<apache::thrift::transport::THeader>>> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback<bool>>(std::move(_promise), recv_wrapped_exists, channel_);
  exists(rpcOptions, std::move(callback), table, tget);
  return _future;
}

folly::SemiFuture<std::pair<bool, std::unique_ptr<apache::thrift::transport::THeader>>> THBaseServiceAsyncClient::header_semifuture_exists(apache::thrift::RpcOptions& rpcOptions, const std::string& table, const  ::apache::hadoop::hbase::thrift2::cpp2::TGet& tget) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_exists, channel_);
  auto callback = std::move(callbackAndFuture.first);
  exists(rpcOptions, std::move(callback), table, tget);
  return std::move(callbackAndFuture.second);
}

void THBaseServiceAsyncClient::exists(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const std::string& table, const  ::apache::hadoop::hbase::thrift2::cpp2::TGet& tget) {
  exists(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), table, tget);
}

folly::exception_wrapper THBaseServiceAsyncClient::recv_wrapped_exists(bool& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = THBaseService_exists_presult;
  constexpr auto const fname = "exists";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

bool THBaseServiceAsyncClient::recv_exists(::apache::thrift::ClientReceiveState& state) {
  bool _return;
  auto ew = recv_wrapped_exists(_return, state);
  if (ew) {
    ew.throw_exception();
  }
  return _return;
}

bool THBaseServiceAsyncClient::recv_instance_exists(::apache::thrift::ClientReceiveState& state) {
  return recv_exists(state);
}

folly::exception_wrapper THBaseServiceAsyncClient::recv_instance_wrapped_exists(bool& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_exists(_return, state);
}

void THBaseServiceAsyncClient::existsAll(std::unique_ptr<apache::thrift::RequestCallback> callback, const std::string& table, const std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TGet>& tgets) {
  ::apache::thrift::RpcOptions rpcOptions;
  existsAllImpl(false, rpcOptions, std::move(callback), table, tgets);
}

void THBaseServiceAsyncClient::existsAll(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const std::string& table, const std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TGet>& tgets) {
  existsAllImpl(false, rpcOptions, std::move(callback), table, tgets);
}

void THBaseServiceAsyncClient::existsAllImpl(bool useSync, apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const std::string& table, const std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TGet>& tgets) {
  switch(getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      existsAllT(&writer, useSync, rpcOptions, std::move(callback), table, tgets);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      existsAllT(&writer, useSync, rpcOptions, std::move(callback), table, tgets);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

void THBaseServiceAsyncClient::sync_existsAll(std::vector<bool>& _return, const std::string& table, const std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TGet>& tgets) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_existsAll(rpcOptions, _return, table, tgets);
}

void THBaseServiceAsyncClient::sync_existsAll(apache::thrift::RpcOptions& rpcOptions, std::vector<bool>& _return, const std::string& table, const std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TGet>& tgets) {
  apache::thrift::ClientReceiveState _returnState;
  auto callback = std::make_unique<apache::thrift::ClientSyncCallback>(
      &_returnState, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE);
  existsAllImpl(true, rpcOptions, std::move(callback), table, tgets);
  SCOPE_EXIT {
    if (_returnState.header() && !_returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(_returnState.header()->releaseHeaders());
    }
  };
  if (!_returnState.buf()) {
    assert(!!_returnState.exception());
    _returnState.exception().throw_exception();
  }
  recv_existsAll(_return, _returnState);
}

folly::Future<std::vector<bool>> THBaseServiceAsyncClient::future_existsAll(const std::string& table, const std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TGet>& tgets) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_existsAll(rpcOptions, table, tgets);
}

folly::SemiFuture<std::vector<bool>> THBaseServiceAsyncClient::semifuture_existsAll(const std::string& table, const std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TGet>& tgets) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_existsAll(rpcOptions, table, tgets);
}

folly::Future<std::vector<bool>> THBaseServiceAsyncClient::future_existsAll(apache::thrift::RpcOptions& rpcOptions, const std::string& table, const std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TGet>& tgets) {
  folly::Promise<std::vector<bool>> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback<std::vector<bool>>>(std::move(_promise), recv_wrapped_existsAll, channel_);
  existsAll(rpcOptions, std::move(callback), table, tgets);
  return _future;
}

folly::SemiFuture<std::vector<bool>> THBaseServiceAsyncClient::semifuture_existsAll(apache::thrift::RpcOptions& rpcOptions, const std::string& table, const std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TGet>& tgets) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_existsAll, channel_);
  auto callback = std::move(callbackAndFuture.first);
  existsAll(rpcOptions, std::move(callback), table, tgets);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair<std::vector<bool>, std::unique_ptr<apache::thrift::transport::THeader>>> THBaseServiceAsyncClient::header_future_existsAll(apache::thrift::RpcOptions& rpcOptions, const std::string& table, const std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TGet>& tgets) {
  folly::Promise<std::pair<std::vector<bool>, std::unique_ptr<apache::thrift::transport::THeader>>> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback<std::vector<bool>>>(std::move(_promise), recv_wrapped_existsAll, channel_);
  existsAll(rpcOptions, std::move(callback), table, tgets);
  return _future;
}

folly::SemiFuture<std::pair<std::vector<bool>, std::unique_ptr<apache::thrift::transport::THeader>>> THBaseServiceAsyncClient::header_semifuture_existsAll(apache::thrift::RpcOptions& rpcOptions, const std::string& table, const std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TGet>& tgets) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_existsAll, channel_);
  auto callback = std::move(callbackAndFuture.first);
  existsAll(rpcOptions, std::move(callback), table, tgets);
  return std::move(callbackAndFuture.second);
}

void THBaseServiceAsyncClient::existsAll(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const std::string& table, const std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TGet>& tgets) {
  existsAll(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), table, tgets);
}

folly::exception_wrapper THBaseServiceAsyncClient::recv_wrapped_existsAll(std::vector<bool>& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = THBaseService_existsAll_presult;
  constexpr auto const fname = "existsAll";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void THBaseServiceAsyncClient::recv_existsAll(std::vector<bool>& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_existsAll(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void THBaseServiceAsyncClient::recv_instance_existsAll(std::vector<bool>& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_existsAll(_return, state);
}

folly::exception_wrapper THBaseServiceAsyncClient::recv_instance_wrapped_existsAll(std::vector<bool>& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_existsAll(_return, state);
}

void THBaseServiceAsyncClient::get(std::unique_ptr<apache::thrift::RequestCallback> callback, const std::string& table, const  ::apache::hadoop::hbase::thrift2::cpp2::TGet& tget) {
  ::apache::thrift::RpcOptions rpcOptions;
  getImpl(false, rpcOptions, std::move(callback), table, tget);
}

void THBaseServiceAsyncClient::get(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const std::string& table, const  ::apache::hadoop::hbase::thrift2::cpp2::TGet& tget) {
  getImpl(false, rpcOptions, std::move(callback), table, tget);
}

void THBaseServiceAsyncClient::getImpl(bool useSync, apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const std::string& table, const  ::apache::hadoop::hbase::thrift2::cpp2::TGet& tget) {
  switch(getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      getT(&writer, useSync, rpcOptions, std::move(callback), table, tget);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      getT(&writer, useSync, rpcOptions, std::move(callback), table, tget);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

void THBaseServiceAsyncClient::sync_get( ::apache::hadoop::hbase::thrift2::cpp2::TResult& _return, const std::string& table, const  ::apache::hadoop::hbase::thrift2::cpp2::TGet& tget) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_get(rpcOptions, _return, table, tget);
}

void THBaseServiceAsyncClient::sync_get(apache::thrift::RpcOptions& rpcOptions,  ::apache::hadoop::hbase::thrift2::cpp2::TResult& _return, const std::string& table, const  ::apache::hadoop::hbase::thrift2::cpp2::TGet& tget) {
  apache::thrift::ClientReceiveState _returnState;
  auto callback = std::make_unique<apache::thrift::ClientSyncCallback>(
      &_returnState, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE);
  getImpl(true, rpcOptions, std::move(callback), table, tget);
  SCOPE_EXIT {
    if (_returnState.header() && !_returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(_returnState.header()->releaseHeaders());
    }
  };
  if (!_returnState.buf()) {
    assert(!!_returnState.exception());
    _returnState.exception().throw_exception();
  }
  recv_get(_return, _returnState);
}

folly::Future< ::apache::hadoop::hbase::thrift2::cpp2::TResult> THBaseServiceAsyncClient::future_get(const std::string& table, const  ::apache::hadoop::hbase::thrift2::cpp2::TGet& tget) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_get(rpcOptions, table, tget);
}

folly::SemiFuture< ::apache::hadoop::hbase::thrift2::cpp2::TResult> THBaseServiceAsyncClient::semifuture_get(const std::string& table, const  ::apache::hadoop::hbase::thrift2::cpp2::TGet& tget) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_get(rpcOptions, table, tget);
}

folly::Future< ::apache::hadoop::hbase::thrift2::cpp2::TResult> THBaseServiceAsyncClient::future_get(apache::thrift::RpcOptions& rpcOptions, const std::string& table, const  ::apache::hadoop::hbase::thrift2::cpp2::TGet& tget) {
  folly::Promise< ::apache::hadoop::hbase::thrift2::cpp2::TResult> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::apache::hadoop::hbase::thrift2::cpp2::TResult>>(std::move(_promise), recv_wrapped_get, channel_);
  get(rpcOptions, std::move(callback), table, tget);
  return _future;
}

folly::SemiFuture< ::apache::hadoop::hbase::thrift2::cpp2::TResult> THBaseServiceAsyncClient::semifuture_get(apache::thrift::RpcOptions& rpcOptions, const std::string& table, const  ::apache::hadoop::hbase::thrift2::cpp2::TGet& tget) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_get, channel_);
  auto callback = std::move(callbackAndFuture.first);
  get(rpcOptions, std::move(callback), table, tget);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::apache::hadoop::hbase::thrift2::cpp2::TResult, std::unique_ptr<apache::thrift::transport::THeader>>> THBaseServiceAsyncClient::header_future_get(apache::thrift::RpcOptions& rpcOptions, const std::string& table, const  ::apache::hadoop::hbase::thrift2::cpp2::TGet& tget) {
  folly::Promise<std::pair< ::apache::hadoop::hbase::thrift2::cpp2::TResult, std::unique_ptr<apache::thrift::transport::THeader>>> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::apache::hadoop::hbase::thrift2::cpp2::TResult>>(std::move(_promise), recv_wrapped_get, channel_);
  get(rpcOptions, std::move(callback), table, tget);
  return _future;
}

folly::SemiFuture<std::pair< ::apache::hadoop::hbase::thrift2::cpp2::TResult, std::unique_ptr<apache::thrift::transport::THeader>>> THBaseServiceAsyncClient::header_semifuture_get(apache::thrift::RpcOptions& rpcOptions, const std::string& table, const  ::apache::hadoop::hbase::thrift2::cpp2::TGet& tget) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_get, channel_);
  auto callback = std::move(callbackAndFuture.first);
  get(rpcOptions, std::move(callback), table, tget);
  return std::move(callbackAndFuture.second);
}

void THBaseServiceAsyncClient::get(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const std::string& table, const  ::apache::hadoop::hbase::thrift2::cpp2::TGet& tget) {
  get(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), table, tget);
}

folly::exception_wrapper THBaseServiceAsyncClient::recv_wrapped_get( ::apache::hadoop::hbase::thrift2::cpp2::TResult& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = THBaseService_get_presult;
  constexpr auto const fname = "get";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void THBaseServiceAsyncClient::recv_get( ::apache::hadoop::hbase::thrift2::cpp2::TResult& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_get(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void THBaseServiceAsyncClient::recv_instance_get( ::apache::hadoop::hbase::thrift2::cpp2::TResult& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_get(_return, state);
}

folly::exception_wrapper THBaseServiceAsyncClient::recv_instance_wrapped_get( ::apache::hadoop::hbase::thrift2::cpp2::TResult& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_get(_return, state);
}

void THBaseServiceAsyncClient::getMultiple(std::unique_ptr<apache::thrift::RequestCallback> callback, const std::string& table, const std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TGet>& tgets) {
  ::apache::thrift::RpcOptions rpcOptions;
  getMultipleImpl(false, rpcOptions, std::move(callback), table, tgets);
}

void THBaseServiceAsyncClient::getMultiple(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const std::string& table, const std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TGet>& tgets) {
  getMultipleImpl(false, rpcOptions, std::move(callback), table, tgets);
}

void THBaseServiceAsyncClient::getMultipleImpl(bool useSync, apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const std::string& table, const std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TGet>& tgets) {
  switch(getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      getMultipleT(&writer, useSync, rpcOptions, std::move(callback), table, tgets);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      getMultipleT(&writer, useSync, rpcOptions, std::move(callback), table, tgets);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

void THBaseServiceAsyncClient::sync_getMultiple(std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TResult>& _return, const std::string& table, const std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TGet>& tgets) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_getMultiple(rpcOptions, _return, table, tgets);
}

void THBaseServiceAsyncClient::sync_getMultiple(apache::thrift::RpcOptions& rpcOptions, std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TResult>& _return, const std::string& table, const std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TGet>& tgets) {
  apache::thrift::ClientReceiveState _returnState;
  auto callback = std::make_unique<apache::thrift::ClientSyncCallback>(
      &_returnState, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE);
  getMultipleImpl(true, rpcOptions, std::move(callback), table, tgets);
  SCOPE_EXIT {
    if (_returnState.header() && !_returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(_returnState.header()->releaseHeaders());
    }
  };
  if (!_returnState.buf()) {
    assert(!!_returnState.exception());
    _returnState.exception().throw_exception();
  }
  recv_getMultiple(_return, _returnState);
}

folly::Future<std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TResult>> THBaseServiceAsyncClient::future_getMultiple(const std::string& table, const std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TGet>& tgets) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_getMultiple(rpcOptions, table, tgets);
}

folly::SemiFuture<std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TResult>> THBaseServiceAsyncClient::semifuture_getMultiple(const std::string& table, const std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TGet>& tgets) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_getMultiple(rpcOptions, table, tgets);
}

folly::Future<std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TResult>> THBaseServiceAsyncClient::future_getMultiple(apache::thrift::RpcOptions& rpcOptions, const std::string& table, const std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TGet>& tgets) {
  folly::Promise<std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TResult>> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback<std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TResult>>>(std::move(_promise), recv_wrapped_getMultiple, channel_);
  getMultiple(rpcOptions, std::move(callback), table, tgets);
  return _future;
}

folly::SemiFuture<std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TResult>> THBaseServiceAsyncClient::semifuture_getMultiple(apache::thrift::RpcOptions& rpcOptions, const std::string& table, const std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TGet>& tgets) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_getMultiple, channel_);
  auto callback = std::move(callbackAndFuture.first);
  getMultiple(rpcOptions, std::move(callback), table, tgets);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair<std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TResult>, std::unique_ptr<apache::thrift::transport::THeader>>> THBaseServiceAsyncClient::header_future_getMultiple(apache::thrift::RpcOptions& rpcOptions, const std::string& table, const std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TGet>& tgets) {
  folly::Promise<std::pair<std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TResult>, std::unique_ptr<apache::thrift::transport::THeader>>> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback<std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TResult>>>(std::move(_promise), recv_wrapped_getMultiple, channel_);
  getMultiple(rpcOptions, std::move(callback), table, tgets);
  return _future;
}

folly::SemiFuture<std::pair<std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TResult>, std::unique_ptr<apache::thrift::transport::THeader>>> THBaseServiceAsyncClient::header_semifuture_getMultiple(apache::thrift::RpcOptions& rpcOptions, const std::string& table, const std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TGet>& tgets) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_getMultiple, channel_);
  auto callback = std::move(callbackAndFuture.first);
  getMultiple(rpcOptions, std::move(callback), table, tgets);
  return std::move(callbackAndFuture.second);
}

void THBaseServiceAsyncClient::getMultiple(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const std::string& table, const std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TGet>& tgets) {
  getMultiple(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), table, tgets);
}

folly::exception_wrapper THBaseServiceAsyncClient::recv_wrapped_getMultiple(std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TResult>& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = THBaseService_getMultiple_presult;
  constexpr auto const fname = "getMultiple";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void THBaseServiceAsyncClient::recv_getMultiple(std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TResult>& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_getMultiple(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void THBaseServiceAsyncClient::recv_instance_getMultiple(std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TResult>& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_getMultiple(_return, state);
}

folly::exception_wrapper THBaseServiceAsyncClient::recv_instance_wrapped_getMultiple(std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TResult>& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_getMultiple(_return, state);
}

void THBaseServiceAsyncClient::put(std::unique_ptr<apache::thrift::RequestCallback> callback, const std::string& table, const  ::apache::hadoop::hbase::thrift2::cpp2::TPut& tput) {
  ::apache::thrift::RpcOptions rpcOptions;
  putImpl(false, rpcOptions, std::move(callback), table, tput);
}

void THBaseServiceAsyncClient::put(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const std::string& table, const  ::apache::hadoop::hbase::thrift2::cpp2::TPut& tput) {
  putImpl(false, rpcOptions, std::move(callback), table, tput);
}

void THBaseServiceAsyncClient::putImpl(bool useSync, apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const std::string& table, const  ::apache::hadoop::hbase::thrift2::cpp2::TPut& tput) {
  switch(getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      putT(&writer, useSync, rpcOptions, std::move(callback), table, tput);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      putT(&writer, useSync, rpcOptions, std::move(callback), table, tput);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

void THBaseServiceAsyncClient::sync_put(const std::string& table, const  ::apache::hadoop::hbase::thrift2::cpp2::TPut& tput) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_put(rpcOptions, table, tput);
}

void THBaseServiceAsyncClient::sync_put(apache::thrift::RpcOptions& rpcOptions, const std::string& table, const  ::apache::hadoop::hbase::thrift2::cpp2::TPut& tput) {
  apache::thrift::ClientReceiveState _returnState;
  auto callback = std::make_unique<apache::thrift::ClientSyncCallback>(
      &_returnState, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE);
  putImpl(true, rpcOptions, std::move(callback), table, tput);
  SCOPE_EXIT {
    if (_returnState.header() && !_returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(_returnState.header()->releaseHeaders());
    }
  };
  if (!_returnState.buf()) {
    assert(!!_returnState.exception());
    _returnState.exception().throw_exception();
  }
  recv_put(_returnState);
}

folly::Future<folly::Unit> THBaseServiceAsyncClient::future_put(const std::string& table, const  ::apache::hadoop::hbase::thrift2::cpp2::TPut& tput) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_put(rpcOptions, table, tput);
}

folly::SemiFuture<folly::Unit> THBaseServiceAsyncClient::semifuture_put(const std::string& table, const  ::apache::hadoop::hbase::thrift2::cpp2::TPut& tput) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_put(rpcOptions, table, tput);
}

folly::Future<folly::Unit> THBaseServiceAsyncClient::future_put(apache::thrift::RpcOptions& rpcOptions, const std::string& table, const  ::apache::hadoop::hbase::thrift2::cpp2::TPut& tput) {
  folly::Promise<folly::Unit> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback<folly::Unit>>(std::move(_promise), recv_wrapped_put, channel_);
  put(rpcOptions, std::move(callback), table, tput);
  return _future;
}

folly::SemiFuture<folly::Unit> THBaseServiceAsyncClient::semifuture_put(apache::thrift::RpcOptions& rpcOptions, const std::string& table, const  ::apache::hadoop::hbase::thrift2::cpp2::TPut& tput) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_put, channel_);
  auto callback = std::move(callbackAndFuture.first);
  put(rpcOptions, std::move(callback), table, tput);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair<folly::Unit, std::unique_ptr<apache::thrift::transport::THeader>>> THBaseServiceAsyncClient::header_future_put(apache::thrift::RpcOptions& rpcOptions, const std::string& table, const  ::apache::hadoop::hbase::thrift2::cpp2::TPut& tput) {
  folly::Promise<std::pair<folly::Unit, std::unique_ptr<apache::thrift::transport::THeader>>> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback<folly::Unit>>(std::move(_promise), recv_wrapped_put, channel_);
  put(rpcOptions, std::move(callback), table, tput);
  return _future;
}

folly::SemiFuture<std::pair<folly::Unit, std::unique_ptr<apache::thrift::transport::THeader>>> THBaseServiceAsyncClient::header_semifuture_put(apache::thrift::RpcOptions& rpcOptions, const std::string& table, const  ::apache::hadoop::hbase::thrift2::cpp2::TPut& tput) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_put, channel_);
  auto callback = std::move(callbackAndFuture.first);
  put(rpcOptions, std::move(callback), table, tput);
  return std::move(callbackAndFuture.second);
}

void THBaseServiceAsyncClient::put(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const std::string& table, const  ::apache::hadoop::hbase::thrift2::cpp2::TPut& tput) {
  put(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), table, tput);
}

folly::exception_wrapper THBaseServiceAsyncClient::recv_wrapped_put(::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = THBaseService_put_presult;
  constexpr auto const fname = "put";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void THBaseServiceAsyncClient::recv_put(::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_put(state);
  if (ew) {
    ew.throw_exception();
  }
}

void THBaseServiceAsyncClient::recv_instance_put(::apache::thrift::ClientReceiveState& state) {
  recv_put(state);
}

folly::exception_wrapper THBaseServiceAsyncClient::recv_instance_wrapped_put(::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_put(state);
}

void THBaseServiceAsyncClient::checkAndPut(std::unique_ptr<apache::thrift::RequestCallback> callback, const std::string& table, const std::string& row, const std::string& family, const std::string& qualifier, const std::string& value, const  ::apache::hadoop::hbase::thrift2::cpp2::TPut& tput) {
  ::apache::thrift::RpcOptions rpcOptions;
  checkAndPutImpl(false, rpcOptions, std::move(callback), table, row, family, qualifier, value, tput);
}

void THBaseServiceAsyncClient::checkAndPut(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const std::string& table, const std::string& row, const std::string& family, const std::string& qualifier, const std::string& value, const  ::apache::hadoop::hbase::thrift2::cpp2::TPut& tput) {
  checkAndPutImpl(false, rpcOptions, std::move(callback), table, row, family, qualifier, value, tput);
}

void THBaseServiceAsyncClient::checkAndPutImpl(bool useSync, apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const std::string& table, const std::string& row, const std::string& family, const std::string& qualifier, const std::string& value, const  ::apache::hadoop::hbase::thrift2::cpp2::TPut& tput) {
  switch(getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      checkAndPutT(&writer, useSync, rpcOptions, std::move(callback), table, row, family, qualifier, value, tput);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      checkAndPutT(&writer, useSync, rpcOptions, std::move(callback), table, row, family, qualifier, value, tput);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

bool THBaseServiceAsyncClient::sync_checkAndPut(const std::string& table, const std::string& row, const std::string& family, const std::string& qualifier, const std::string& value, const  ::apache::hadoop::hbase::thrift2::cpp2::TPut& tput) {
  ::apache::thrift::RpcOptions rpcOptions;
  return sync_checkAndPut(rpcOptions, table, row, family, qualifier, value, tput);
}

bool THBaseServiceAsyncClient::sync_checkAndPut(apache::thrift::RpcOptions& rpcOptions, const std::string& table, const std::string& row, const std::string& family, const std::string& qualifier, const std::string& value, const  ::apache::hadoop::hbase::thrift2::cpp2::TPut& tput) {
  apache::thrift::ClientReceiveState _returnState;
  auto callback = std::make_unique<apache::thrift::ClientSyncCallback>(
      &_returnState, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE);
  checkAndPutImpl(true, rpcOptions, std::move(callback), table, row, family, qualifier, value, tput);
  SCOPE_EXIT {
    if (_returnState.header() && !_returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(_returnState.header()->releaseHeaders());
    }
  };
  if (!_returnState.buf()) {
    assert(!!_returnState.exception());
    _returnState.exception().throw_exception();
  }
  return recv_checkAndPut(_returnState);
}

folly::Future<bool> THBaseServiceAsyncClient::future_checkAndPut(const std::string& table, const std::string& row, const std::string& family, const std::string& qualifier, const std::string& value, const  ::apache::hadoop::hbase::thrift2::cpp2::TPut& tput) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_checkAndPut(rpcOptions, table, row, family, qualifier, value, tput);
}

folly::SemiFuture<bool> THBaseServiceAsyncClient::semifuture_checkAndPut(const std::string& table, const std::string& row, const std::string& family, const std::string& qualifier, const std::string& value, const  ::apache::hadoop::hbase::thrift2::cpp2::TPut& tput) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_checkAndPut(rpcOptions, table, row, family, qualifier, value, tput);
}

folly::Future<bool> THBaseServiceAsyncClient::future_checkAndPut(apache::thrift::RpcOptions& rpcOptions, const std::string& table, const std::string& row, const std::string& family, const std::string& qualifier, const std::string& value, const  ::apache::hadoop::hbase::thrift2::cpp2::TPut& tput) {
  folly::Promise<bool> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback<bool>>(std::move(_promise), recv_wrapped_checkAndPut, channel_);
  checkAndPut(rpcOptions, std::move(callback), table, row, family, qualifier, value, tput);
  return _future;
}

folly::SemiFuture<bool> THBaseServiceAsyncClient::semifuture_checkAndPut(apache::thrift::RpcOptions& rpcOptions, const std::string& table, const std::string& row, const std::string& family, const std::string& qualifier, const std::string& value, const  ::apache::hadoop::hbase::thrift2::cpp2::TPut& tput) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_checkAndPut, channel_);
  auto callback = std::move(callbackAndFuture.first);
  checkAndPut(rpcOptions, std::move(callback), table, row, family, qualifier, value, tput);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair<bool, std::unique_ptr<apache::thrift::transport::THeader>>> THBaseServiceAsyncClient::header_future_checkAndPut(apache::thrift::RpcOptions& rpcOptions, const std::string& table, const std::string& row, const std::string& family, const std::string& qualifier, const std::string& value, const  ::apache::hadoop::hbase::thrift2::cpp2::TPut& tput) {
  folly::Promise<std::pair<bool, std::unique_ptr<apache::thrift::transport::THeader>>> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback<bool>>(std::move(_promise), recv_wrapped_checkAndPut, channel_);
  checkAndPut(rpcOptions, std::move(callback), table, row, family, qualifier, value, tput);
  return _future;
}

folly::SemiFuture<std::pair<bool, std::unique_ptr<apache::thrift::transport::THeader>>> THBaseServiceAsyncClient::header_semifuture_checkAndPut(apache::thrift::RpcOptions& rpcOptions, const std::string& table, const std::string& row, const std::string& family, const std::string& qualifier, const std::string& value, const  ::apache::hadoop::hbase::thrift2::cpp2::TPut& tput) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_checkAndPut, channel_);
  auto callback = std::move(callbackAndFuture.first);
  checkAndPut(rpcOptions, std::move(callback), table, row, family, qualifier, value, tput);
  return std::move(callbackAndFuture.second);
}

void THBaseServiceAsyncClient::checkAndPut(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const std::string& table, const std::string& row, const std::string& family, const std::string& qualifier, const std::string& value, const  ::apache::hadoop::hbase::thrift2::cpp2::TPut& tput) {
  checkAndPut(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), table, row, family, qualifier, value, tput);
}

folly::exception_wrapper THBaseServiceAsyncClient::recv_wrapped_checkAndPut(bool& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = THBaseService_checkAndPut_presult;
  constexpr auto const fname = "checkAndPut";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

bool THBaseServiceAsyncClient::recv_checkAndPut(::apache::thrift::ClientReceiveState& state) {
  bool _return;
  auto ew = recv_wrapped_checkAndPut(_return, state);
  if (ew) {
    ew.throw_exception();
  }
  return _return;
}

bool THBaseServiceAsyncClient::recv_instance_checkAndPut(::apache::thrift::ClientReceiveState& state) {
  return recv_checkAndPut(state);
}

folly::exception_wrapper THBaseServiceAsyncClient::recv_instance_wrapped_checkAndPut(bool& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_checkAndPut(_return, state);
}

void THBaseServiceAsyncClient::putMultiple(std::unique_ptr<apache::thrift::RequestCallback> callback, const std::string& table, const std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TPut>& tputs) {
  ::apache::thrift::RpcOptions rpcOptions;
  putMultipleImpl(false, rpcOptions, std::move(callback), table, tputs);
}

void THBaseServiceAsyncClient::putMultiple(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const std::string& table, const std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TPut>& tputs) {
  putMultipleImpl(false, rpcOptions, std::move(callback), table, tputs);
}

void THBaseServiceAsyncClient::putMultipleImpl(bool useSync, apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const std::string& table, const std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TPut>& tputs) {
  switch(getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      putMultipleT(&writer, useSync, rpcOptions, std::move(callback), table, tputs);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      putMultipleT(&writer, useSync, rpcOptions, std::move(callback), table, tputs);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

void THBaseServiceAsyncClient::sync_putMultiple(const std::string& table, const std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TPut>& tputs) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_putMultiple(rpcOptions, table, tputs);
}

void THBaseServiceAsyncClient::sync_putMultiple(apache::thrift::RpcOptions& rpcOptions, const std::string& table, const std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TPut>& tputs) {
  apache::thrift::ClientReceiveState _returnState;
  auto callback = std::make_unique<apache::thrift::ClientSyncCallback>(
      &_returnState, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE);
  putMultipleImpl(true, rpcOptions, std::move(callback), table, tputs);
  SCOPE_EXIT {
    if (_returnState.header() && !_returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(_returnState.header()->releaseHeaders());
    }
  };
  if (!_returnState.buf()) {
    assert(!!_returnState.exception());
    _returnState.exception().throw_exception();
  }
  recv_putMultiple(_returnState);
}

folly::Future<folly::Unit> THBaseServiceAsyncClient::future_putMultiple(const std::string& table, const std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TPut>& tputs) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_putMultiple(rpcOptions, table, tputs);
}

folly::SemiFuture<folly::Unit> THBaseServiceAsyncClient::semifuture_putMultiple(const std::string& table, const std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TPut>& tputs) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_putMultiple(rpcOptions, table, tputs);
}

folly::Future<folly::Unit> THBaseServiceAsyncClient::future_putMultiple(apache::thrift::RpcOptions& rpcOptions, const std::string& table, const std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TPut>& tputs) {
  folly::Promise<folly::Unit> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback<folly::Unit>>(std::move(_promise), recv_wrapped_putMultiple, channel_);
  putMultiple(rpcOptions, std::move(callback), table, tputs);
  return _future;
}

folly::SemiFuture<folly::Unit> THBaseServiceAsyncClient::semifuture_putMultiple(apache::thrift::RpcOptions& rpcOptions, const std::string& table, const std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TPut>& tputs) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_putMultiple, channel_);
  auto callback = std::move(callbackAndFuture.first);
  putMultiple(rpcOptions, std::move(callback), table, tputs);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair<folly::Unit, std::unique_ptr<apache::thrift::transport::THeader>>> THBaseServiceAsyncClient::header_future_putMultiple(apache::thrift::RpcOptions& rpcOptions, const std::string& table, const std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TPut>& tputs) {
  folly::Promise<std::pair<folly::Unit, std::unique_ptr<apache::thrift::transport::THeader>>> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback<folly::Unit>>(std::move(_promise), recv_wrapped_putMultiple, channel_);
  putMultiple(rpcOptions, std::move(callback), table, tputs);
  return _future;
}

folly::SemiFuture<std::pair<folly::Unit, std::unique_ptr<apache::thrift::transport::THeader>>> THBaseServiceAsyncClient::header_semifuture_putMultiple(apache::thrift::RpcOptions& rpcOptions, const std::string& table, const std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TPut>& tputs) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_putMultiple, channel_);
  auto callback = std::move(callbackAndFuture.first);
  putMultiple(rpcOptions, std::move(callback), table, tputs);
  return std::move(callbackAndFuture.second);
}

void THBaseServiceAsyncClient::putMultiple(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const std::string& table, const std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TPut>& tputs) {
  putMultiple(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), table, tputs);
}

folly::exception_wrapper THBaseServiceAsyncClient::recv_wrapped_putMultiple(::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = THBaseService_putMultiple_presult;
  constexpr auto const fname = "putMultiple";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void THBaseServiceAsyncClient::recv_putMultiple(::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_putMultiple(state);
  if (ew) {
    ew.throw_exception();
  }
}

void THBaseServiceAsyncClient::recv_instance_putMultiple(::apache::thrift::ClientReceiveState& state) {
  recv_putMultiple(state);
}

folly::exception_wrapper THBaseServiceAsyncClient::recv_instance_wrapped_putMultiple(::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_putMultiple(state);
}

void THBaseServiceAsyncClient::deleteSingle(std::unique_ptr<apache::thrift::RequestCallback> callback, const std::string& table, const  ::apache::hadoop::hbase::thrift2::cpp2::TDelete& tdelete) {
  ::apache::thrift::RpcOptions rpcOptions;
  deleteSingleImpl(false, rpcOptions, std::move(callback), table, tdelete);
}

void THBaseServiceAsyncClient::deleteSingle(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const std::string& table, const  ::apache::hadoop::hbase::thrift2::cpp2::TDelete& tdelete) {
  deleteSingleImpl(false, rpcOptions, std::move(callback), table, tdelete);
}

void THBaseServiceAsyncClient::deleteSingleImpl(bool useSync, apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const std::string& table, const  ::apache::hadoop::hbase::thrift2::cpp2::TDelete& tdelete) {
  switch(getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      deleteSingleT(&writer, useSync, rpcOptions, std::move(callback), table, tdelete);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      deleteSingleT(&writer, useSync, rpcOptions, std::move(callback), table, tdelete);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

void THBaseServiceAsyncClient::sync_deleteSingle(const std::string& table, const  ::apache::hadoop::hbase::thrift2::cpp2::TDelete& tdelete) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_deleteSingle(rpcOptions, table, tdelete);
}

void THBaseServiceAsyncClient::sync_deleteSingle(apache::thrift::RpcOptions& rpcOptions, const std::string& table, const  ::apache::hadoop::hbase::thrift2::cpp2::TDelete& tdelete) {
  apache::thrift::ClientReceiveState _returnState;
  auto callback = std::make_unique<apache::thrift::ClientSyncCallback>(
      &_returnState, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE);
  deleteSingleImpl(true, rpcOptions, std::move(callback), table, tdelete);
  SCOPE_EXIT {
    if (_returnState.header() && !_returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(_returnState.header()->releaseHeaders());
    }
  };
  if (!_returnState.buf()) {
    assert(!!_returnState.exception());
    _returnState.exception().throw_exception();
  }
  recv_deleteSingle(_returnState);
}

folly::Future<folly::Unit> THBaseServiceAsyncClient::future_deleteSingle(const std::string& table, const  ::apache::hadoop::hbase::thrift2::cpp2::TDelete& tdelete) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_deleteSingle(rpcOptions, table, tdelete);
}

folly::SemiFuture<folly::Unit> THBaseServiceAsyncClient::semifuture_deleteSingle(const std::string& table, const  ::apache::hadoop::hbase::thrift2::cpp2::TDelete& tdelete) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_deleteSingle(rpcOptions, table, tdelete);
}

folly::Future<folly::Unit> THBaseServiceAsyncClient::future_deleteSingle(apache::thrift::RpcOptions& rpcOptions, const std::string& table, const  ::apache::hadoop::hbase::thrift2::cpp2::TDelete& tdelete) {
  folly::Promise<folly::Unit> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback<folly::Unit>>(std::move(_promise), recv_wrapped_deleteSingle, channel_);
  deleteSingle(rpcOptions, std::move(callback), table, tdelete);
  return _future;
}

folly::SemiFuture<folly::Unit> THBaseServiceAsyncClient::semifuture_deleteSingle(apache::thrift::RpcOptions& rpcOptions, const std::string& table, const  ::apache::hadoop::hbase::thrift2::cpp2::TDelete& tdelete) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_deleteSingle, channel_);
  auto callback = std::move(callbackAndFuture.first);
  deleteSingle(rpcOptions, std::move(callback), table, tdelete);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair<folly::Unit, std::unique_ptr<apache::thrift::transport::THeader>>> THBaseServiceAsyncClient::header_future_deleteSingle(apache::thrift::RpcOptions& rpcOptions, const std::string& table, const  ::apache::hadoop::hbase::thrift2::cpp2::TDelete& tdelete) {
  folly::Promise<std::pair<folly::Unit, std::unique_ptr<apache::thrift::transport::THeader>>> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback<folly::Unit>>(std::move(_promise), recv_wrapped_deleteSingle, channel_);
  deleteSingle(rpcOptions, std::move(callback), table, tdelete);
  return _future;
}

folly::SemiFuture<std::pair<folly::Unit, std::unique_ptr<apache::thrift::transport::THeader>>> THBaseServiceAsyncClient::header_semifuture_deleteSingle(apache::thrift::RpcOptions& rpcOptions, const std::string& table, const  ::apache::hadoop::hbase::thrift2::cpp2::TDelete& tdelete) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_deleteSingle, channel_);
  auto callback = std::move(callbackAndFuture.first);
  deleteSingle(rpcOptions, std::move(callback), table, tdelete);
  return std::move(callbackAndFuture.second);
}

void THBaseServiceAsyncClient::deleteSingle(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const std::string& table, const  ::apache::hadoop::hbase::thrift2::cpp2::TDelete& tdelete) {
  deleteSingle(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), table, tdelete);
}

folly::exception_wrapper THBaseServiceAsyncClient::recv_wrapped_deleteSingle(::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = THBaseService_deleteSingle_presult;
  constexpr auto const fname = "deleteSingle";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void THBaseServiceAsyncClient::recv_deleteSingle(::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_deleteSingle(state);
  if (ew) {
    ew.throw_exception();
  }
}

void THBaseServiceAsyncClient::recv_instance_deleteSingle(::apache::thrift::ClientReceiveState& state) {
  recv_deleteSingle(state);
}

folly::exception_wrapper THBaseServiceAsyncClient::recv_instance_wrapped_deleteSingle(::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_deleteSingle(state);
}

void THBaseServiceAsyncClient::deleteMultiple(std::unique_ptr<apache::thrift::RequestCallback> callback, const std::string& table, const std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TDelete>& tdeletes) {
  ::apache::thrift::RpcOptions rpcOptions;
  deleteMultipleImpl(false, rpcOptions, std::move(callback), table, tdeletes);
}

void THBaseServiceAsyncClient::deleteMultiple(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const std::string& table, const std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TDelete>& tdeletes) {
  deleteMultipleImpl(false, rpcOptions, std::move(callback), table, tdeletes);
}

void THBaseServiceAsyncClient::deleteMultipleImpl(bool useSync, apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const std::string& table, const std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TDelete>& tdeletes) {
  switch(getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      deleteMultipleT(&writer, useSync, rpcOptions, std::move(callback), table, tdeletes);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      deleteMultipleT(&writer, useSync, rpcOptions, std::move(callback), table, tdeletes);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

void THBaseServiceAsyncClient::sync_deleteMultiple(std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TDelete>& _return, const std::string& table, const std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TDelete>& tdeletes) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_deleteMultiple(rpcOptions, _return, table, tdeletes);
}

void THBaseServiceAsyncClient::sync_deleteMultiple(apache::thrift::RpcOptions& rpcOptions, std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TDelete>& _return, const std::string& table, const std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TDelete>& tdeletes) {
  apache::thrift::ClientReceiveState _returnState;
  auto callback = std::make_unique<apache::thrift::ClientSyncCallback>(
      &_returnState, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE);
  deleteMultipleImpl(true, rpcOptions, std::move(callback), table, tdeletes);
  SCOPE_EXIT {
    if (_returnState.header() && !_returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(_returnState.header()->releaseHeaders());
    }
  };
  if (!_returnState.buf()) {
    assert(!!_returnState.exception());
    _returnState.exception().throw_exception();
  }
  recv_deleteMultiple(_return, _returnState);
}

folly::Future<std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TDelete>> THBaseServiceAsyncClient::future_deleteMultiple(const std::string& table, const std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TDelete>& tdeletes) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_deleteMultiple(rpcOptions, table, tdeletes);
}

folly::SemiFuture<std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TDelete>> THBaseServiceAsyncClient::semifuture_deleteMultiple(const std::string& table, const std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TDelete>& tdeletes) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_deleteMultiple(rpcOptions, table, tdeletes);
}

folly::Future<std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TDelete>> THBaseServiceAsyncClient::future_deleteMultiple(apache::thrift::RpcOptions& rpcOptions, const std::string& table, const std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TDelete>& tdeletes) {
  folly::Promise<std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TDelete>> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback<std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TDelete>>>(std::move(_promise), recv_wrapped_deleteMultiple, channel_);
  deleteMultiple(rpcOptions, std::move(callback), table, tdeletes);
  return _future;
}

folly::SemiFuture<std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TDelete>> THBaseServiceAsyncClient::semifuture_deleteMultiple(apache::thrift::RpcOptions& rpcOptions, const std::string& table, const std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TDelete>& tdeletes) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_deleteMultiple, channel_);
  auto callback = std::move(callbackAndFuture.first);
  deleteMultiple(rpcOptions, std::move(callback), table, tdeletes);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair<std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TDelete>, std::unique_ptr<apache::thrift::transport::THeader>>> THBaseServiceAsyncClient::header_future_deleteMultiple(apache::thrift::RpcOptions& rpcOptions, const std::string& table, const std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TDelete>& tdeletes) {
  folly::Promise<std::pair<std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TDelete>, std::unique_ptr<apache::thrift::transport::THeader>>> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback<std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TDelete>>>(std::move(_promise), recv_wrapped_deleteMultiple, channel_);
  deleteMultiple(rpcOptions, std::move(callback), table, tdeletes);
  return _future;
}

folly::SemiFuture<std::pair<std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TDelete>, std::unique_ptr<apache::thrift::transport::THeader>>> THBaseServiceAsyncClient::header_semifuture_deleteMultiple(apache::thrift::RpcOptions& rpcOptions, const std::string& table, const std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TDelete>& tdeletes) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_deleteMultiple, channel_);
  auto callback = std::move(callbackAndFuture.first);
  deleteMultiple(rpcOptions, std::move(callback), table, tdeletes);
  return std::move(callbackAndFuture.second);
}

void THBaseServiceAsyncClient::deleteMultiple(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const std::string& table, const std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TDelete>& tdeletes) {
  deleteMultiple(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), table, tdeletes);
}

folly::exception_wrapper THBaseServiceAsyncClient::recv_wrapped_deleteMultiple(std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TDelete>& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = THBaseService_deleteMultiple_presult;
  constexpr auto const fname = "deleteMultiple";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void THBaseServiceAsyncClient::recv_deleteMultiple(std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TDelete>& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_deleteMultiple(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void THBaseServiceAsyncClient::recv_instance_deleteMultiple(std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TDelete>& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_deleteMultiple(_return, state);
}

folly::exception_wrapper THBaseServiceAsyncClient::recv_instance_wrapped_deleteMultiple(std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TDelete>& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_deleteMultiple(_return, state);
}

void THBaseServiceAsyncClient::checkAndDelete(std::unique_ptr<apache::thrift::RequestCallback> callback, const std::string& table, const std::string& row, const std::string& family, const std::string& qualifier, const std::string& value, const  ::apache::hadoop::hbase::thrift2::cpp2::TDelete& tdelete) {
  ::apache::thrift::RpcOptions rpcOptions;
  checkAndDeleteImpl(false, rpcOptions, std::move(callback), table, row, family, qualifier, value, tdelete);
}

void THBaseServiceAsyncClient::checkAndDelete(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const std::string& table, const std::string& row, const std::string& family, const std::string& qualifier, const std::string& value, const  ::apache::hadoop::hbase::thrift2::cpp2::TDelete& tdelete) {
  checkAndDeleteImpl(false, rpcOptions, std::move(callback), table, row, family, qualifier, value, tdelete);
}

void THBaseServiceAsyncClient::checkAndDeleteImpl(bool useSync, apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const std::string& table, const std::string& row, const std::string& family, const std::string& qualifier, const std::string& value, const  ::apache::hadoop::hbase::thrift2::cpp2::TDelete& tdelete) {
  switch(getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      checkAndDeleteT(&writer, useSync, rpcOptions, std::move(callback), table, row, family, qualifier, value, tdelete);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      checkAndDeleteT(&writer, useSync, rpcOptions, std::move(callback), table, row, family, qualifier, value, tdelete);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

bool THBaseServiceAsyncClient::sync_checkAndDelete(const std::string& table, const std::string& row, const std::string& family, const std::string& qualifier, const std::string& value, const  ::apache::hadoop::hbase::thrift2::cpp2::TDelete& tdelete) {
  ::apache::thrift::RpcOptions rpcOptions;
  return sync_checkAndDelete(rpcOptions, table, row, family, qualifier, value, tdelete);
}

bool THBaseServiceAsyncClient::sync_checkAndDelete(apache::thrift::RpcOptions& rpcOptions, const std::string& table, const std::string& row, const std::string& family, const std::string& qualifier, const std::string& value, const  ::apache::hadoop::hbase::thrift2::cpp2::TDelete& tdelete) {
  apache::thrift::ClientReceiveState _returnState;
  auto callback = std::make_unique<apache::thrift::ClientSyncCallback>(
      &_returnState, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE);
  checkAndDeleteImpl(true, rpcOptions, std::move(callback), table, row, family, qualifier, value, tdelete);
  SCOPE_EXIT {
    if (_returnState.header() && !_returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(_returnState.header()->releaseHeaders());
    }
  };
  if (!_returnState.buf()) {
    assert(!!_returnState.exception());
    _returnState.exception().throw_exception();
  }
  return recv_checkAndDelete(_returnState);
}

folly::Future<bool> THBaseServiceAsyncClient::future_checkAndDelete(const std::string& table, const std::string& row, const std::string& family, const std::string& qualifier, const std::string& value, const  ::apache::hadoop::hbase::thrift2::cpp2::TDelete& tdelete) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_checkAndDelete(rpcOptions, table, row, family, qualifier, value, tdelete);
}

folly::SemiFuture<bool> THBaseServiceAsyncClient::semifuture_checkAndDelete(const std::string& table, const std::string& row, const std::string& family, const std::string& qualifier, const std::string& value, const  ::apache::hadoop::hbase::thrift2::cpp2::TDelete& tdelete) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_checkAndDelete(rpcOptions, table, row, family, qualifier, value, tdelete);
}

folly::Future<bool> THBaseServiceAsyncClient::future_checkAndDelete(apache::thrift::RpcOptions& rpcOptions, const std::string& table, const std::string& row, const std::string& family, const std::string& qualifier, const std::string& value, const  ::apache::hadoop::hbase::thrift2::cpp2::TDelete& tdelete) {
  folly::Promise<bool> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback<bool>>(std::move(_promise), recv_wrapped_checkAndDelete, channel_);
  checkAndDelete(rpcOptions, std::move(callback), table, row, family, qualifier, value, tdelete);
  return _future;
}

folly::SemiFuture<bool> THBaseServiceAsyncClient::semifuture_checkAndDelete(apache::thrift::RpcOptions& rpcOptions, const std::string& table, const std::string& row, const std::string& family, const std::string& qualifier, const std::string& value, const  ::apache::hadoop::hbase::thrift2::cpp2::TDelete& tdelete) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_checkAndDelete, channel_);
  auto callback = std::move(callbackAndFuture.first);
  checkAndDelete(rpcOptions, std::move(callback), table, row, family, qualifier, value, tdelete);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair<bool, std::unique_ptr<apache::thrift::transport::THeader>>> THBaseServiceAsyncClient::header_future_checkAndDelete(apache::thrift::RpcOptions& rpcOptions, const std::string& table, const std::string& row, const std::string& family, const std::string& qualifier, const std::string& value, const  ::apache::hadoop::hbase::thrift2::cpp2::TDelete& tdelete) {
  folly::Promise<std::pair<bool, std::unique_ptr<apache::thrift::transport::THeader>>> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback<bool>>(std::move(_promise), recv_wrapped_checkAndDelete, channel_);
  checkAndDelete(rpcOptions, std::move(callback), table, row, family, qualifier, value, tdelete);
  return _future;
}

folly::SemiFuture<std::pair<bool, std::unique_ptr<apache::thrift::transport::THeader>>> THBaseServiceAsyncClient::header_semifuture_checkAndDelete(apache::thrift::RpcOptions& rpcOptions, const std::string& table, const std::string& row, const std::string& family, const std::string& qualifier, const std::string& value, const  ::apache::hadoop::hbase::thrift2::cpp2::TDelete& tdelete) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_checkAndDelete, channel_);
  auto callback = std::move(callbackAndFuture.first);
  checkAndDelete(rpcOptions, std::move(callback), table, row, family, qualifier, value, tdelete);
  return std::move(callbackAndFuture.second);
}

void THBaseServiceAsyncClient::checkAndDelete(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const std::string& table, const std::string& row, const std::string& family, const std::string& qualifier, const std::string& value, const  ::apache::hadoop::hbase::thrift2::cpp2::TDelete& tdelete) {
  checkAndDelete(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), table, row, family, qualifier, value, tdelete);
}

folly::exception_wrapper THBaseServiceAsyncClient::recv_wrapped_checkAndDelete(bool& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = THBaseService_checkAndDelete_presult;
  constexpr auto const fname = "checkAndDelete";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

bool THBaseServiceAsyncClient::recv_checkAndDelete(::apache::thrift::ClientReceiveState& state) {
  bool _return;
  auto ew = recv_wrapped_checkAndDelete(_return, state);
  if (ew) {
    ew.throw_exception();
  }
  return _return;
}

bool THBaseServiceAsyncClient::recv_instance_checkAndDelete(::apache::thrift::ClientReceiveState& state) {
  return recv_checkAndDelete(state);
}

folly::exception_wrapper THBaseServiceAsyncClient::recv_instance_wrapped_checkAndDelete(bool& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_checkAndDelete(_return, state);
}

void THBaseServiceAsyncClient::increment(std::unique_ptr<apache::thrift::RequestCallback> callback, const std::string& table, const  ::apache::hadoop::hbase::thrift2::cpp2::TIncrement& tincrement) {
  ::apache::thrift::RpcOptions rpcOptions;
  incrementImpl(false, rpcOptions, std::move(callback), table, tincrement);
}

void THBaseServiceAsyncClient::increment(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const std::string& table, const  ::apache::hadoop::hbase::thrift2::cpp2::TIncrement& tincrement) {
  incrementImpl(false, rpcOptions, std::move(callback), table, tincrement);
}

void THBaseServiceAsyncClient::incrementImpl(bool useSync, apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const std::string& table, const  ::apache::hadoop::hbase::thrift2::cpp2::TIncrement& tincrement) {
  switch(getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      incrementT(&writer, useSync, rpcOptions, std::move(callback), table, tincrement);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      incrementT(&writer, useSync, rpcOptions, std::move(callback), table, tincrement);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

void THBaseServiceAsyncClient::sync_increment( ::apache::hadoop::hbase::thrift2::cpp2::TResult& _return, const std::string& table, const  ::apache::hadoop::hbase::thrift2::cpp2::TIncrement& tincrement) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_increment(rpcOptions, _return, table, tincrement);
}

void THBaseServiceAsyncClient::sync_increment(apache::thrift::RpcOptions& rpcOptions,  ::apache::hadoop::hbase::thrift2::cpp2::TResult& _return, const std::string& table, const  ::apache::hadoop::hbase::thrift2::cpp2::TIncrement& tincrement) {
  apache::thrift::ClientReceiveState _returnState;
  auto callback = std::make_unique<apache::thrift::ClientSyncCallback>(
      &_returnState, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE);
  incrementImpl(true, rpcOptions, std::move(callback), table, tincrement);
  SCOPE_EXIT {
    if (_returnState.header() && !_returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(_returnState.header()->releaseHeaders());
    }
  };
  if (!_returnState.buf()) {
    assert(!!_returnState.exception());
    _returnState.exception().throw_exception();
  }
  recv_increment(_return, _returnState);
}

folly::Future< ::apache::hadoop::hbase::thrift2::cpp2::TResult> THBaseServiceAsyncClient::future_increment(const std::string& table, const  ::apache::hadoop::hbase::thrift2::cpp2::TIncrement& tincrement) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_increment(rpcOptions, table, tincrement);
}

folly::SemiFuture< ::apache::hadoop::hbase::thrift2::cpp2::TResult> THBaseServiceAsyncClient::semifuture_increment(const std::string& table, const  ::apache::hadoop::hbase::thrift2::cpp2::TIncrement& tincrement) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_increment(rpcOptions, table, tincrement);
}

folly::Future< ::apache::hadoop::hbase::thrift2::cpp2::TResult> THBaseServiceAsyncClient::future_increment(apache::thrift::RpcOptions& rpcOptions, const std::string& table, const  ::apache::hadoop::hbase::thrift2::cpp2::TIncrement& tincrement) {
  folly::Promise< ::apache::hadoop::hbase::thrift2::cpp2::TResult> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::apache::hadoop::hbase::thrift2::cpp2::TResult>>(std::move(_promise), recv_wrapped_increment, channel_);
  increment(rpcOptions, std::move(callback), table, tincrement);
  return _future;
}

folly::SemiFuture< ::apache::hadoop::hbase::thrift2::cpp2::TResult> THBaseServiceAsyncClient::semifuture_increment(apache::thrift::RpcOptions& rpcOptions, const std::string& table, const  ::apache::hadoop::hbase::thrift2::cpp2::TIncrement& tincrement) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_increment, channel_);
  auto callback = std::move(callbackAndFuture.first);
  increment(rpcOptions, std::move(callback), table, tincrement);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::apache::hadoop::hbase::thrift2::cpp2::TResult, std::unique_ptr<apache::thrift::transport::THeader>>> THBaseServiceAsyncClient::header_future_increment(apache::thrift::RpcOptions& rpcOptions, const std::string& table, const  ::apache::hadoop::hbase::thrift2::cpp2::TIncrement& tincrement) {
  folly::Promise<std::pair< ::apache::hadoop::hbase::thrift2::cpp2::TResult, std::unique_ptr<apache::thrift::transport::THeader>>> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::apache::hadoop::hbase::thrift2::cpp2::TResult>>(std::move(_promise), recv_wrapped_increment, channel_);
  increment(rpcOptions, std::move(callback), table, tincrement);
  return _future;
}

folly::SemiFuture<std::pair< ::apache::hadoop::hbase::thrift2::cpp2::TResult, std::unique_ptr<apache::thrift::transport::THeader>>> THBaseServiceAsyncClient::header_semifuture_increment(apache::thrift::RpcOptions& rpcOptions, const std::string& table, const  ::apache::hadoop::hbase::thrift2::cpp2::TIncrement& tincrement) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_increment, channel_);
  auto callback = std::move(callbackAndFuture.first);
  increment(rpcOptions, std::move(callback), table, tincrement);
  return std::move(callbackAndFuture.second);
}

void THBaseServiceAsyncClient::increment(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const std::string& table, const  ::apache::hadoop::hbase::thrift2::cpp2::TIncrement& tincrement) {
  increment(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), table, tincrement);
}

folly::exception_wrapper THBaseServiceAsyncClient::recv_wrapped_increment( ::apache::hadoop::hbase::thrift2::cpp2::TResult& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = THBaseService_increment_presult;
  constexpr auto const fname = "increment";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void THBaseServiceAsyncClient::recv_increment( ::apache::hadoop::hbase::thrift2::cpp2::TResult& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_increment(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void THBaseServiceAsyncClient::recv_instance_increment( ::apache::hadoop::hbase::thrift2::cpp2::TResult& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_increment(_return, state);
}

folly::exception_wrapper THBaseServiceAsyncClient::recv_instance_wrapped_increment( ::apache::hadoop::hbase::thrift2::cpp2::TResult& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_increment(_return, state);
}

void THBaseServiceAsyncClient::append(std::unique_ptr<apache::thrift::RequestCallback> callback, const std::string& table, const  ::apache::hadoop::hbase::thrift2::cpp2::TAppend& tappend) {
  ::apache::thrift::RpcOptions rpcOptions;
  appendImpl(false, rpcOptions, std::move(callback), table, tappend);
}

void THBaseServiceAsyncClient::append(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const std::string& table, const  ::apache::hadoop::hbase::thrift2::cpp2::TAppend& tappend) {
  appendImpl(false, rpcOptions, std::move(callback), table, tappend);
}

void THBaseServiceAsyncClient::appendImpl(bool useSync, apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const std::string& table, const  ::apache::hadoop::hbase::thrift2::cpp2::TAppend& tappend) {
  switch(getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      appendT(&writer, useSync, rpcOptions, std::move(callback), table, tappend);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      appendT(&writer, useSync, rpcOptions, std::move(callback), table, tappend);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

void THBaseServiceAsyncClient::sync_append( ::apache::hadoop::hbase::thrift2::cpp2::TResult& _return, const std::string& table, const  ::apache::hadoop::hbase::thrift2::cpp2::TAppend& tappend) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_append(rpcOptions, _return, table, tappend);
}

void THBaseServiceAsyncClient::sync_append(apache::thrift::RpcOptions& rpcOptions,  ::apache::hadoop::hbase::thrift2::cpp2::TResult& _return, const std::string& table, const  ::apache::hadoop::hbase::thrift2::cpp2::TAppend& tappend) {
  apache::thrift::ClientReceiveState _returnState;
  auto callback = std::make_unique<apache::thrift::ClientSyncCallback>(
      &_returnState, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE);
  appendImpl(true, rpcOptions, std::move(callback), table, tappend);
  SCOPE_EXIT {
    if (_returnState.header() && !_returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(_returnState.header()->releaseHeaders());
    }
  };
  if (!_returnState.buf()) {
    assert(!!_returnState.exception());
    _returnState.exception().throw_exception();
  }
  recv_append(_return, _returnState);
}

folly::Future< ::apache::hadoop::hbase::thrift2::cpp2::TResult> THBaseServiceAsyncClient::future_append(const std::string& table, const  ::apache::hadoop::hbase::thrift2::cpp2::TAppend& tappend) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_append(rpcOptions, table, tappend);
}

folly::SemiFuture< ::apache::hadoop::hbase::thrift2::cpp2::TResult> THBaseServiceAsyncClient::semifuture_append(const std::string& table, const  ::apache::hadoop::hbase::thrift2::cpp2::TAppend& tappend) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_append(rpcOptions, table, tappend);
}

folly::Future< ::apache::hadoop::hbase::thrift2::cpp2::TResult> THBaseServiceAsyncClient::future_append(apache::thrift::RpcOptions& rpcOptions, const std::string& table, const  ::apache::hadoop::hbase::thrift2::cpp2::TAppend& tappend) {
  folly::Promise< ::apache::hadoop::hbase::thrift2::cpp2::TResult> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::apache::hadoop::hbase::thrift2::cpp2::TResult>>(std::move(_promise), recv_wrapped_append, channel_);
  append(rpcOptions, std::move(callback), table, tappend);
  return _future;
}

folly::SemiFuture< ::apache::hadoop::hbase::thrift2::cpp2::TResult> THBaseServiceAsyncClient::semifuture_append(apache::thrift::RpcOptions& rpcOptions, const std::string& table, const  ::apache::hadoop::hbase::thrift2::cpp2::TAppend& tappend) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_append, channel_);
  auto callback = std::move(callbackAndFuture.first);
  append(rpcOptions, std::move(callback), table, tappend);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::apache::hadoop::hbase::thrift2::cpp2::TResult, std::unique_ptr<apache::thrift::transport::THeader>>> THBaseServiceAsyncClient::header_future_append(apache::thrift::RpcOptions& rpcOptions, const std::string& table, const  ::apache::hadoop::hbase::thrift2::cpp2::TAppend& tappend) {
  folly::Promise<std::pair< ::apache::hadoop::hbase::thrift2::cpp2::TResult, std::unique_ptr<apache::thrift::transport::THeader>>> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::apache::hadoop::hbase::thrift2::cpp2::TResult>>(std::move(_promise), recv_wrapped_append, channel_);
  append(rpcOptions, std::move(callback), table, tappend);
  return _future;
}

folly::SemiFuture<std::pair< ::apache::hadoop::hbase::thrift2::cpp2::TResult, std::unique_ptr<apache::thrift::transport::THeader>>> THBaseServiceAsyncClient::header_semifuture_append(apache::thrift::RpcOptions& rpcOptions, const std::string& table, const  ::apache::hadoop::hbase::thrift2::cpp2::TAppend& tappend) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_append, channel_);
  auto callback = std::move(callbackAndFuture.first);
  append(rpcOptions, std::move(callback), table, tappend);
  return std::move(callbackAndFuture.second);
}

void THBaseServiceAsyncClient::append(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const std::string& table, const  ::apache::hadoop::hbase::thrift2::cpp2::TAppend& tappend) {
  append(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), table, tappend);
}

folly::exception_wrapper THBaseServiceAsyncClient::recv_wrapped_append( ::apache::hadoop::hbase::thrift2::cpp2::TResult& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = THBaseService_append_presult;
  constexpr auto const fname = "append";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void THBaseServiceAsyncClient::recv_append( ::apache::hadoop::hbase::thrift2::cpp2::TResult& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_append(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void THBaseServiceAsyncClient::recv_instance_append( ::apache::hadoop::hbase::thrift2::cpp2::TResult& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_append(_return, state);
}

folly::exception_wrapper THBaseServiceAsyncClient::recv_instance_wrapped_append( ::apache::hadoop::hbase::thrift2::cpp2::TResult& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_append(_return, state);
}

void THBaseServiceAsyncClient::openScanner(std::unique_ptr<apache::thrift::RequestCallback> callback, const std::string& table, const  ::apache::hadoop::hbase::thrift2::cpp2::TScan& tscan) {
  ::apache::thrift::RpcOptions rpcOptions;
  openScannerImpl(false, rpcOptions, std::move(callback), table, tscan);
}

void THBaseServiceAsyncClient::openScanner(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const std::string& table, const  ::apache::hadoop::hbase::thrift2::cpp2::TScan& tscan) {
  openScannerImpl(false, rpcOptions, std::move(callback), table, tscan);
}

void THBaseServiceAsyncClient::openScannerImpl(bool useSync, apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const std::string& table, const  ::apache::hadoop::hbase::thrift2::cpp2::TScan& tscan) {
  switch(getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      openScannerT(&writer, useSync, rpcOptions, std::move(callback), table, tscan);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      openScannerT(&writer, useSync, rpcOptions, std::move(callback), table, tscan);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

int32_t THBaseServiceAsyncClient::sync_openScanner(const std::string& table, const  ::apache::hadoop::hbase::thrift2::cpp2::TScan& tscan) {
  ::apache::thrift::RpcOptions rpcOptions;
  return sync_openScanner(rpcOptions, table, tscan);
}

int32_t THBaseServiceAsyncClient::sync_openScanner(apache::thrift::RpcOptions& rpcOptions, const std::string& table, const  ::apache::hadoop::hbase::thrift2::cpp2::TScan& tscan) {
  apache::thrift::ClientReceiveState _returnState;
  auto callback = std::make_unique<apache::thrift::ClientSyncCallback>(
      &_returnState, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE);
  openScannerImpl(true, rpcOptions, std::move(callback), table, tscan);
  SCOPE_EXIT {
    if (_returnState.header() && !_returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(_returnState.header()->releaseHeaders());
    }
  };
  if (!_returnState.buf()) {
    assert(!!_returnState.exception());
    _returnState.exception().throw_exception();
  }
  return recv_openScanner(_returnState);
}

folly::Future<int32_t> THBaseServiceAsyncClient::future_openScanner(const std::string& table, const  ::apache::hadoop::hbase::thrift2::cpp2::TScan& tscan) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_openScanner(rpcOptions, table, tscan);
}

folly::SemiFuture<int32_t> THBaseServiceAsyncClient::semifuture_openScanner(const std::string& table, const  ::apache::hadoop::hbase::thrift2::cpp2::TScan& tscan) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_openScanner(rpcOptions, table, tscan);
}

folly::Future<int32_t> THBaseServiceAsyncClient::future_openScanner(apache::thrift::RpcOptions& rpcOptions, const std::string& table, const  ::apache::hadoop::hbase::thrift2::cpp2::TScan& tscan) {
  folly::Promise<int32_t> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback<int32_t>>(std::move(_promise), recv_wrapped_openScanner, channel_);
  openScanner(rpcOptions, std::move(callback), table, tscan);
  return _future;
}

folly::SemiFuture<int32_t> THBaseServiceAsyncClient::semifuture_openScanner(apache::thrift::RpcOptions& rpcOptions, const std::string& table, const  ::apache::hadoop::hbase::thrift2::cpp2::TScan& tscan) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_openScanner, channel_);
  auto callback = std::move(callbackAndFuture.first);
  openScanner(rpcOptions, std::move(callback), table, tscan);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair<int32_t, std::unique_ptr<apache::thrift::transport::THeader>>> THBaseServiceAsyncClient::header_future_openScanner(apache::thrift::RpcOptions& rpcOptions, const std::string& table, const  ::apache::hadoop::hbase::thrift2::cpp2::TScan& tscan) {
  folly::Promise<std::pair<int32_t, std::unique_ptr<apache::thrift::transport::THeader>>> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback<int32_t>>(std::move(_promise), recv_wrapped_openScanner, channel_);
  openScanner(rpcOptions, std::move(callback), table, tscan);
  return _future;
}

folly::SemiFuture<std::pair<int32_t, std::unique_ptr<apache::thrift::transport::THeader>>> THBaseServiceAsyncClient::header_semifuture_openScanner(apache::thrift::RpcOptions& rpcOptions, const std::string& table, const  ::apache::hadoop::hbase::thrift2::cpp2::TScan& tscan) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_openScanner, channel_);
  auto callback = std::move(callbackAndFuture.first);
  openScanner(rpcOptions, std::move(callback), table, tscan);
  return std::move(callbackAndFuture.second);
}

void THBaseServiceAsyncClient::openScanner(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const std::string& table, const  ::apache::hadoop::hbase::thrift2::cpp2::TScan& tscan) {
  openScanner(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), table, tscan);
}

folly::exception_wrapper THBaseServiceAsyncClient::recv_wrapped_openScanner(int32_t& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = THBaseService_openScanner_presult;
  constexpr auto const fname = "openScanner";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

int32_t THBaseServiceAsyncClient::recv_openScanner(::apache::thrift::ClientReceiveState& state) {
  int32_t _return;
  auto ew = recv_wrapped_openScanner(_return, state);
  if (ew) {
    ew.throw_exception();
  }
  return _return;
}

int32_t THBaseServiceAsyncClient::recv_instance_openScanner(::apache::thrift::ClientReceiveState& state) {
  return recv_openScanner(state);
}

folly::exception_wrapper THBaseServiceAsyncClient::recv_instance_wrapped_openScanner(int32_t& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_openScanner(_return, state);
}

void THBaseServiceAsyncClient::getScannerRows(std::unique_ptr<apache::thrift::RequestCallback> callback, int32_t scannerId, int32_t numRows) {
  ::apache::thrift::RpcOptions rpcOptions;
  getScannerRowsImpl(false, rpcOptions, std::move(callback), scannerId, numRows);
}

void THBaseServiceAsyncClient::getScannerRows(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, int32_t scannerId, int32_t numRows) {
  getScannerRowsImpl(false, rpcOptions, std::move(callback), scannerId, numRows);
}

void THBaseServiceAsyncClient::getScannerRowsImpl(bool useSync, apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, int32_t scannerId, int32_t numRows) {
  switch(getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      getScannerRowsT(&writer, useSync, rpcOptions, std::move(callback), scannerId, numRows);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      getScannerRowsT(&writer, useSync, rpcOptions, std::move(callback), scannerId, numRows);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

void THBaseServiceAsyncClient::sync_getScannerRows(std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TResult>& _return, int32_t scannerId, int32_t numRows) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_getScannerRows(rpcOptions, _return, scannerId, numRows);
}

void THBaseServiceAsyncClient::sync_getScannerRows(apache::thrift::RpcOptions& rpcOptions, std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TResult>& _return, int32_t scannerId, int32_t numRows) {
  apache::thrift::ClientReceiveState _returnState;
  auto callback = std::make_unique<apache::thrift::ClientSyncCallback>(
      &_returnState, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE);
  getScannerRowsImpl(true, rpcOptions, std::move(callback), scannerId, numRows);
  SCOPE_EXIT {
    if (_returnState.header() && !_returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(_returnState.header()->releaseHeaders());
    }
  };
  if (!_returnState.buf()) {
    assert(!!_returnState.exception());
    _returnState.exception().throw_exception();
  }
  recv_getScannerRows(_return, _returnState);
}

folly::Future<std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TResult>> THBaseServiceAsyncClient::future_getScannerRows(int32_t scannerId, int32_t numRows) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_getScannerRows(rpcOptions, scannerId, numRows);
}

folly::SemiFuture<std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TResult>> THBaseServiceAsyncClient::semifuture_getScannerRows(int32_t scannerId, int32_t numRows) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_getScannerRows(rpcOptions, scannerId, numRows);
}

folly::Future<std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TResult>> THBaseServiceAsyncClient::future_getScannerRows(apache::thrift::RpcOptions& rpcOptions, int32_t scannerId, int32_t numRows) {
  folly::Promise<std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TResult>> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback<std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TResult>>>(std::move(_promise), recv_wrapped_getScannerRows, channel_);
  getScannerRows(rpcOptions, std::move(callback), scannerId, numRows);
  return _future;
}

folly::SemiFuture<std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TResult>> THBaseServiceAsyncClient::semifuture_getScannerRows(apache::thrift::RpcOptions& rpcOptions, int32_t scannerId, int32_t numRows) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_getScannerRows, channel_);
  auto callback = std::move(callbackAndFuture.first);
  getScannerRows(rpcOptions, std::move(callback), scannerId, numRows);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair<std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TResult>, std::unique_ptr<apache::thrift::transport::THeader>>> THBaseServiceAsyncClient::header_future_getScannerRows(apache::thrift::RpcOptions& rpcOptions, int32_t scannerId, int32_t numRows) {
  folly::Promise<std::pair<std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TResult>, std::unique_ptr<apache::thrift::transport::THeader>>> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback<std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TResult>>>(std::move(_promise), recv_wrapped_getScannerRows, channel_);
  getScannerRows(rpcOptions, std::move(callback), scannerId, numRows);
  return _future;
}

folly::SemiFuture<std::pair<std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TResult>, std::unique_ptr<apache::thrift::transport::THeader>>> THBaseServiceAsyncClient::header_semifuture_getScannerRows(apache::thrift::RpcOptions& rpcOptions, int32_t scannerId, int32_t numRows) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_getScannerRows, channel_);
  auto callback = std::move(callbackAndFuture.first);
  getScannerRows(rpcOptions, std::move(callback), scannerId, numRows);
  return std::move(callbackAndFuture.second);
}

void THBaseServiceAsyncClient::getScannerRows(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, int32_t scannerId, int32_t numRows) {
  getScannerRows(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), scannerId, numRows);
}

folly::exception_wrapper THBaseServiceAsyncClient::recv_wrapped_getScannerRows(std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TResult>& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = THBaseService_getScannerRows_presult;
  constexpr auto const fname = "getScannerRows";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void THBaseServiceAsyncClient::recv_getScannerRows(std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TResult>& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_getScannerRows(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void THBaseServiceAsyncClient::recv_instance_getScannerRows(std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TResult>& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_getScannerRows(_return, state);
}

folly::exception_wrapper THBaseServiceAsyncClient::recv_instance_wrapped_getScannerRows(std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TResult>& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_getScannerRows(_return, state);
}

void THBaseServiceAsyncClient::closeScanner(std::unique_ptr<apache::thrift::RequestCallback> callback, int32_t scannerId) {
  ::apache::thrift::RpcOptions rpcOptions;
  closeScannerImpl(false, rpcOptions, std::move(callback), scannerId);
}

void THBaseServiceAsyncClient::closeScanner(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, int32_t scannerId) {
  closeScannerImpl(false, rpcOptions, std::move(callback), scannerId);
}

void THBaseServiceAsyncClient::closeScannerImpl(bool useSync, apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, int32_t scannerId) {
  switch(getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      closeScannerT(&writer, useSync, rpcOptions, std::move(callback), scannerId);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      closeScannerT(&writer, useSync, rpcOptions, std::move(callback), scannerId);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

void THBaseServiceAsyncClient::sync_closeScanner(int32_t scannerId) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_closeScanner(rpcOptions, scannerId);
}

void THBaseServiceAsyncClient::sync_closeScanner(apache::thrift::RpcOptions& rpcOptions, int32_t scannerId) {
  apache::thrift::ClientReceiveState _returnState;
  auto callback = std::make_unique<apache::thrift::ClientSyncCallback>(
      &_returnState, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE);
  closeScannerImpl(true, rpcOptions, std::move(callback), scannerId);
  SCOPE_EXIT {
    if (_returnState.header() && !_returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(_returnState.header()->releaseHeaders());
    }
  };
  if (!_returnState.buf()) {
    assert(!!_returnState.exception());
    _returnState.exception().throw_exception();
  }
  recv_closeScanner(_returnState);
}

folly::Future<folly::Unit> THBaseServiceAsyncClient::future_closeScanner(int32_t scannerId) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_closeScanner(rpcOptions, scannerId);
}

folly::SemiFuture<folly::Unit> THBaseServiceAsyncClient::semifuture_closeScanner(int32_t scannerId) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_closeScanner(rpcOptions, scannerId);
}

folly::Future<folly::Unit> THBaseServiceAsyncClient::future_closeScanner(apache::thrift::RpcOptions& rpcOptions, int32_t scannerId) {
  folly::Promise<folly::Unit> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback<folly::Unit>>(std::move(_promise), recv_wrapped_closeScanner, channel_);
  closeScanner(rpcOptions, std::move(callback), scannerId);
  return _future;
}

folly::SemiFuture<folly::Unit> THBaseServiceAsyncClient::semifuture_closeScanner(apache::thrift::RpcOptions& rpcOptions, int32_t scannerId) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_closeScanner, channel_);
  auto callback = std::move(callbackAndFuture.first);
  closeScanner(rpcOptions, std::move(callback), scannerId);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair<folly::Unit, std::unique_ptr<apache::thrift::transport::THeader>>> THBaseServiceAsyncClient::header_future_closeScanner(apache::thrift::RpcOptions& rpcOptions, int32_t scannerId) {
  folly::Promise<std::pair<folly::Unit, std::unique_ptr<apache::thrift::transport::THeader>>> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback<folly::Unit>>(std::move(_promise), recv_wrapped_closeScanner, channel_);
  closeScanner(rpcOptions, std::move(callback), scannerId);
  return _future;
}

folly::SemiFuture<std::pair<folly::Unit, std::unique_ptr<apache::thrift::transport::THeader>>> THBaseServiceAsyncClient::header_semifuture_closeScanner(apache::thrift::RpcOptions& rpcOptions, int32_t scannerId) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_closeScanner, channel_);
  auto callback = std::move(callbackAndFuture.first);
  closeScanner(rpcOptions, std::move(callback), scannerId);
  return std::move(callbackAndFuture.second);
}

void THBaseServiceAsyncClient::closeScanner(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, int32_t scannerId) {
  closeScanner(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), scannerId);
}

folly::exception_wrapper THBaseServiceAsyncClient::recv_wrapped_closeScanner(::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = THBaseService_closeScanner_presult;
  constexpr auto const fname = "closeScanner";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void THBaseServiceAsyncClient::recv_closeScanner(::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_closeScanner(state);
  if (ew) {
    ew.throw_exception();
  }
}

void THBaseServiceAsyncClient::recv_instance_closeScanner(::apache::thrift::ClientReceiveState& state) {
  recv_closeScanner(state);
}

folly::exception_wrapper THBaseServiceAsyncClient::recv_instance_wrapped_closeScanner(::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_closeScanner(state);
}

void THBaseServiceAsyncClient::mutateRow(std::unique_ptr<apache::thrift::RequestCallback> callback, const std::string& table, const  ::apache::hadoop::hbase::thrift2::cpp2::TRowMutations& trowMutations) {
  ::apache::thrift::RpcOptions rpcOptions;
  mutateRowImpl(false, rpcOptions, std::move(callback), table, trowMutations);
}

void THBaseServiceAsyncClient::mutateRow(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const std::string& table, const  ::apache::hadoop::hbase::thrift2::cpp2::TRowMutations& trowMutations) {
  mutateRowImpl(false, rpcOptions, std::move(callback), table, trowMutations);
}

void THBaseServiceAsyncClient::mutateRowImpl(bool useSync, apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const std::string& table, const  ::apache::hadoop::hbase::thrift2::cpp2::TRowMutations& trowMutations) {
  switch(getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      mutateRowT(&writer, useSync, rpcOptions, std::move(callback), table, trowMutations);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      mutateRowT(&writer, useSync, rpcOptions, std::move(callback), table, trowMutations);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

void THBaseServiceAsyncClient::sync_mutateRow(const std::string& table, const  ::apache::hadoop::hbase::thrift2::cpp2::TRowMutations& trowMutations) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_mutateRow(rpcOptions, table, trowMutations);
}

void THBaseServiceAsyncClient::sync_mutateRow(apache::thrift::RpcOptions& rpcOptions, const std::string& table, const  ::apache::hadoop::hbase::thrift2::cpp2::TRowMutations& trowMutations) {
  apache::thrift::ClientReceiveState _returnState;
  auto callback = std::make_unique<apache::thrift::ClientSyncCallback>(
      &_returnState, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE);
  mutateRowImpl(true, rpcOptions, std::move(callback), table, trowMutations);
  SCOPE_EXIT {
    if (_returnState.header() && !_returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(_returnState.header()->releaseHeaders());
    }
  };
  if (!_returnState.buf()) {
    assert(!!_returnState.exception());
    _returnState.exception().throw_exception();
  }
  recv_mutateRow(_returnState);
}

folly::Future<folly::Unit> THBaseServiceAsyncClient::future_mutateRow(const std::string& table, const  ::apache::hadoop::hbase::thrift2::cpp2::TRowMutations& trowMutations) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_mutateRow(rpcOptions, table, trowMutations);
}

folly::SemiFuture<folly::Unit> THBaseServiceAsyncClient::semifuture_mutateRow(const std::string& table, const  ::apache::hadoop::hbase::thrift2::cpp2::TRowMutations& trowMutations) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_mutateRow(rpcOptions, table, trowMutations);
}

folly::Future<folly::Unit> THBaseServiceAsyncClient::future_mutateRow(apache::thrift::RpcOptions& rpcOptions, const std::string& table, const  ::apache::hadoop::hbase::thrift2::cpp2::TRowMutations& trowMutations) {
  folly::Promise<folly::Unit> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback<folly::Unit>>(std::move(_promise), recv_wrapped_mutateRow, channel_);
  mutateRow(rpcOptions, std::move(callback), table, trowMutations);
  return _future;
}

folly::SemiFuture<folly::Unit> THBaseServiceAsyncClient::semifuture_mutateRow(apache::thrift::RpcOptions& rpcOptions, const std::string& table, const  ::apache::hadoop::hbase::thrift2::cpp2::TRowMutations& trowMutations) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_mutateRow, channel_);
  auto callback = std::move(callbackAndFuture.first);
  mutateRow(rpcOptions, std::move(callback), table, trowMutations);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair<folly::Unit, std::unique_ptr<apache::thrift::transport::THeader>>> THBaseServiceAsyncClient::header_future_mutateRow(apache::thrift::RpcOptions& rpcOptions, const std::string& table, const  ::apache::hadoop::hbase::thrift2::cpp2::TRowMutations& trowMutations) {
  folly::Promise<std::pair<folly::Unit, std::unique_ptr<apache::thrift::transport::THeader>>> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback<folly::Unit>>(std::move(_promise), recv_wrapped_mutateRow, channel_);
  mutateRow(rpcOptions, std::move(callback), table, trowMutations);
  return _future;
}

folly::SemiFuture<std::pair<folly::Unit, std::unique_ptr<apache::thrift::transport::THeader>>> THBaseServiceAsyncClient::header_semifuture_mutateRow(apache::thrift::RpcOptions& rpcOptions, const std::string& table, const  ::apache::hadoop::hbase::thrift2::cpp2::TRowMutations& trowMutations) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_mutateRow, channel_);
  auto callback = std::move(callbackAndFuture.first);
  mutateRow(rpcOptions, std::move(callback), table, trowMutations);
  return std::move(callbackAndFuture.second);
}

void THBaseServiceAsyncClient::mutateRow(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const std::string& table, const  ::apache::hadoop::hbase::thrift2::cpp2::TRowMutations& trowMutations) {
  mutateRow(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), table, trowMutations);
}

folly::exception_wrapper THBaseServiceAsyncClient::recv_wrapped_mutateRow(::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = THBaseService_mutateRow_presult;
  constexpr auto const fname = "mutateRow";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void THBaseServiceAsyncClient::recv_mutateRow(::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_mutateRow(state);
  if (ew) {
    ew.throw_exception();
  }
}

void THBaseServiceAsyncClient::recv_instance_mutateRow(::apache::thrift::ClientReceiveState& state) {
  recv_mutateRow(state);
}

folly::exception_wrapper THBaseServiceAsyncClient::recv_instance_wrapped_mutateRow(::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_mutateRow(state);
}

void THBaseServiceAsyncClient::getScannerResults(std::unique_ptr<apache::thrift::RequestCallback> callback, const std::string& table, const  ::apache::hadoop::hbase::thrift2::cpp2::TScan& tscan, int32_t numRows) {
  ::apache::thrift::RpcOptions rpcOptions;
  getScannerResultsImpl(false, rpcOptions, std::move(callback), table, tscan, numRows);
}

void THBaseServiceAsyncClient::getScannerResults(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const std::string& table, const  ::apache::hadoop::hbase::thrift2::cpp2::TScan& tscan, int32_t numRows) {
  getScannerResultsImpl(false, rpcOptions, std::move(callback), table, tscan, numRows);
}

void THBaseServiceAsyncClient::getScannerResultsImpl(bool useSync, apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const std::string& table, const  ::apache::hadoop::hbase::thrift2::cpp2::TScan& tscan, int32_t numRows) {
  switch(getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      getScannerResultsT(&writer, useSync, rpcOptions, std::move(callback), table, tscan, numRows);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      getScannerResultsT(&writer, useSync, rpcOptions, std::move(callback), table, tscan, numRows);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

void THBaseServiceAsyncClient::sync_getScannerResults(std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TResult>& _return, const std::string& table, const  ::apache::hadoop::hbase::thrift2::cpp2::TScan& tscan, int32_t numRows) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_getScannerResults(rpcOptions, _return, table, tscan, numRows);
}

void THBaseServiceAsyncClient::sync_getScannerResults(apache::thrift::RpcOptions& rpcOptions, std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TResult>& _return, const std::string& table, const  ::apache::hadoop::hbase::thrift2::cpp2::TScan& tscan, int32_t numRows) {
  apache::thrift::ClientReceiveState _returnState;
  auto callback = std::make_unique<apache::thrift::ClientSyncCallback>(
      &_returnState, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE);
  getScannerResultsImpl(true, rpcOptions, std::move(callback), table, tscan, numRows);
  SCOPE_EXIT {
    if (_returnState.header() && !_returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(_returnState.header()->releaseHeaders());
    }
  };
  if (!_returnState.buf()) {
    assert(!!_returnState.exception());
    _returnState.exception().throw_exception();
  }
  recv_getScannerResults(_return, _returnState);
}

folly::Future<std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TResult>> THBaseServiceAsyncClient::future_getScannerResults(const std::string& table, const  ::apache::hadoop::hbase::thrift2::cpp2::TScan& tscan, int32_t numRows) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_getScannerResults(rpcOptions, table, tscan, numRows);
}

folly::SemiFuture<std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TResult>> THBaseServiceAsyncClient::semifuture_getScannerResults(const std::string& table, const  ::apache::hadoop::hbase::thrift2::cpp2::TScan& tscan, int32_t numRows) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_getScannerResults(rpcOptions, table, tscan, numRows);
}

folly::Future<std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TResult>> THBaseServiceAsyncClient::future_getScannerResults(apache::thrift::RpcOptions& rpcOptions, const std::string& table, const  ::apache::hadoop::hbase::thrift2::cpp2::TScan& tscan, int32_t numRows) {
  folly::Promise<std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TResult>> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback<std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TResult>>>(std::move(_promise), recv_wrapped_getScannerResults, channel_);
  getScannerResults(rpcOptions, std::move(callback), table, tscan, numRows);
  return _future;
}

folly::SemiFuture<std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TResult>> THBaseServiceAsyncClient::semifuture_getScannerResults(apache::thrift::RpcOptions& rpcOptions, const std::string& table, const  ::apache::hadoop::hbase::thrift2::cpp2::TScan& tscan, int32_t numRows) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_getScannerResults, channel_);
  auto callback = std::move(callbackAndFuture.first);
  getScannerResults(rpcOptions, std::move(callback), table, tscan, numRows);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair<std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TResult>, std::unique_ptr<apache::thrift::transport::THeader>>> THBaseServiceAsyncClient::header_future_getScannerResults(apache::thrift::RpcOptions& rpcOptions, const std::string& table, const  ::apache::hadoop::hbase::thrift2::cpp2::TScan& tscan, int32_t numRows) {
  folly::Promise<std::pair<std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TResult>, std::unique_ptr<apache::thrift::transport::THeader>>> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback<std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TResult>>>(std::move(_promise), recv_wrapped_getScannerResults, channel_);
  getScannerResults(rpcOptions, std::move(callback), table, tscan, numRows);
  return _future;
}

folly::SemiFuture<std::pair<std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TResult>, std::unique_ptr<apache::thrift::transport::THeader>>> THBaseServiceAsyncClient::header_semifuture_getScannerResults(apache::thrift::RpcOptions& rpcOptions, const std::string& table, const  ::apache::hadoop::hbase::thrift2::cpp2::TScan& tscan, int32_t numRows) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_getScannerResults, channel_);
  auto callback = std::move(callbackAndFuture.first);
  getScannerResults(rpcOptions, std::move(callback), table, tscan, numRows);
  return std::move(callbackAndFuture.second);
}

void THBaseServiceAsyncClient::getScannerResults(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const std::string& table, const  ::apache::hadoop::hbase::thrift2::cpp2::TScan& tscan, int32_t numRows) {
  getScannerResults(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), table, tscan, numRows);
}

folly::exception_wrapper THBaseServiceAsyncClient::recv_wrapped_getScannerResults(std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TResult>& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = THBaseService_getScannerResults_presult;
  constexpr auto const fname = "getScannerResults";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void THBaseServiceAsyncClient::recv_getScannerResults(std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TResult>& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_getScannerResults(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void THBaseServiceAsyncClient::recv_instance_getScannerResults(std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TResult>& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_getScannerResults(_return, state);
}

folly::exception_wrapper THBaseServiceAsyncClient::recv_instance_wrapped_getScannerResults(std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TResult>& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_getScannerResults(_return, state);
}

void THBaseServiceAsyncClient::getRegionLocation(std::unique_ptr<apache::thrift::RequestCallback> callback, const std::string& table, const std::string& row, bool reload) {
  ::apache::thrift::RpcOptions rpcOptions;
  getRegionLocationImpl(false, rpcOptions, std::move(callback), table, row, reload);
}

void THBaseServiceAsyncClient::getRegionLocation(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const std::string& table, const std::string& row, bool reload) {
  getRegionLocationImpl(false, rpcOptions, std::move(callback), table, row, reload);
}

void THBaseServiceAsyncClient::getRegionLocationImpl(bool useSync, apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const std::string& table, const std::string& row, bool reload) {
  switch(getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      getRegionLocationT(&writer, useSync, rpcOptions, std::move(callback), table, row, reload);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      getRegionLocationT(&writer, useSync, rpcOptions, std::move(callback), table, row, reload);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

void THBaseServiceAsyncClient::sync_getRegionLocation( ::apache::hadoop::hbase::thrift2::cpp2::THRegionLocation& _return, const std::string& table, const std::string& row, bool reload) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_getRegionLocation(rpcOptions, _return, table, row, reload);
}

void THBaseServiceAsyncClient::sync_getRegionLocation(apache::thrift::RpcOptions& rpcOptions,  ::apache::hadoop::hbase::thrift2::cpp2::THRegionLocation& _return, const std::string& table, const std::string& row, bool reload) {
  apache::thrift::ClientReceiveState _returnState;
  auto callback = std::make_unique<apache::thrift::ClientSyncCallback>(
      &_returnState, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE);
  getRegionLocationImpl(true, rpcOptions, std::move(callback), table, row, reload);
  SCOPE_EXIT {
    if (_returnState.header() && !_returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(_returnState.header()->releaseHeaders());
    }
  };
  if (!_returnState.buf()) {
    assert(!!_returnState.exception());
    _returnState.exception().throw_exception();
  }
  recv_getRegionLocation(_return, _returnState);
}

folly::Future< ::apache::hadoop::hbase::thrift2::cpp2::THRegionLocation> THBaseServiceAsyncClient::future_getRegionLocation(const std::string& table, const std::string& row, bool reload) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_getRegionLocation(rpcOptions, table, row, reload);
}

folly::SemiFuture< ::apache::hadoop::hbase::thrift2::cpp2::THRegionLocation> THBaseServiceAsyncClient::semifuture_getRegionLocation(const std::string& table, const std::string& row, bool reload) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_getRegionLocation(rpcOptions, table, row, reload);
}

folly::Future< ::apache::hadoop::hbase::thrift2::cpp2::THRegionLocation> THBaseServiceAsyncClient::future_getRegionLocation(apache::thrift::RpcOptions& rpcOptions, const std::string& table, const std::string& row, bool reload) {
  folly::Promise< ::apache::hadoop::hbase::thrift2::cpp2::THRegionLocation> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::apache::hadoop::hbase::thrift2::cpp2::THRegionLocation>>(std::move(_promise), recv_wrapped_getRegionLocation, channel_);
  getRegionLocation(rpcOptions, std::move(callback), table, row, reload);
  return _future;
}

folly::SemiFuture< ::apache::hadoop::hbase::thrift2::cpp2::THRegionLocation> THBaseServiceAsyncClient::semifuture_getRegionLocation(apache::thrift::RpcOptions& rpcOptions, const std::string& table, const std::string& row, bool reload) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_getRegionLocation, channel_);
  auto callback = std::move(callbackAndFuture.first);
  getRegionLocation(rpcOptions, std::move(callback), table, row, reload);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::apache::hadoop::hbase::thrift2::cpp2::THRegionLocation, std::unique_ptr<apache::thrift::transport::THeader>>> THBaseServiceAsyncClient::header_future_getRegionLocation(apache::thrift::RpcOptions& rpcOptions, const std::string& table, const std::string& row, bool reload) {
  folly::Promise<std::pair< ::apache::hadoop::hbase::thrift2::cpp2::THRegionLocation, std::unique_ptr<apache::thrift::transport::THeader>>> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::apache::hadoop::hbase::thrift2::cpp2::THRegionLocation>>(std::move(_promise), recv_wrapped_getRegionLocation, channel_);
  getRegionLocation(rpcOptions, std::move(callback), table, row, reload);
  return _future;
}

folly::SemiFuture<std::pair< ::apache::hadoop::hbase::thrift2::cpp2::THRegionLocation, std::unique_ptr<apache::thrift::transport::THeader>>> THBaseServiceAsyncClient::header_semifuture_getRegionLocation(apache::thrift::RpcOptions& rpcOptions, const std::string& table, const std::string& row, bool reload) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_getRegionLocation, channel_);
  auto callback = std::move(callbackAndFuture.first);
  getRegionLocation(rpcOptions, std::move(callback), table, row, reload);
  return std::move(callbackAndFuture.second);
}

void THBaseServiceAsyncClient::getRegionLocation(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const std::string& table, const std::string& row, bool reload) {
  getRegionLocation(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), table, row, reload);
}

folly::exception_wrapper THBaseServiceAsyncClient::recv_wrapped_getRegionLocation( ::apache::hadoop::hbase::thrift2::cpp2::THRegionLocation& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = THBaseService_getRegionLocation_presult;
  constexpr auto const fname = "getRegionLocation";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void THBaseServiceAsyncClient::recv_getRegionLocation( ::apache::hadoop::hbase::thrift2::cpp2::THRegionLocation& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_getRegionLocation(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void THBaseServiceAsyncClient::recv_instance_getRegionLocation( ::apache::hadoop::hbase::thrift2::cpp2::THRegionLocation& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_getRegionLocation(_return, state);
}

folly::exception_wrapper THBaseServiceAsyncClient::recv_instance_wrapped_getRegionLocation( ::apache::hadoop::hbase::thrift2::cpp2::THRegionLocation& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_getRegionLocation(_return, state);
}

void THBaseServiceAsyncClient::getAllRegionLocations(std::unique_ptr<apache::thrift::RequestCallback> callback, const std::string& table) {
  ::apache::thrift::RpcOptions rpcOptions;
  getAllRegionLocationsImpl(false, rpcOptions, std::move(callback), table);
}

void THBaseServiceAsyncClient::getAllRegionLocations(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const std::string& table) {
  getAllRegionLocationsImpl(false, rpcOptions, std::move(callback), table);
}

void THBaseServiceAsyncClient::getAllRegionLocationsImpl(bool useSync, apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const std::string& table) {
  switch(getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      getAllRegionLocationsT(&writer, useSync, rpcOptions, std::move(callback), table);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      getAllRegionLocationsT(&writer, useSync, rpcOptions, std::move(callback), table);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

void THBaseServiceAsyncClient::sync_getAllRegionLocations(std::vector< ::apache::hadoop::hbase::thrift2::cpp2::THRegionLocation>& _return, const std::string& table) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_getAllRegionLocations(rpcOptions, _return, table);
}

void THBaseServiceAsyncClient::sync_getAllRegionLocations(apache::thrift::RpcOptions& rpcOptions, std::vector< ::apache::hadoop::hbase::thrift2::cpp2::THRegionLocation>& _return, const std::string& table) {
  apache::thrift::ClientReceiveState _returnState;
  auto callback = std::make_unique<apache::thrift::ClientSyncCallback>(
      &_returnState, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE);
  getAllRegionLocationsImpl(true, rpcOptions, std::move(callback), table);
  SCOPE_EXIT {
    if (_returnState.header() && !_returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(_returnState.header()->releaseHeaders());
    }
  };
  if (!_returnState.buf()) {
    assert(!!_returnState.exception());
    _returnState.exception().throw_exception();
  }
  recv_getAllRegionLocations(_return, _returnState);
}

folly::Future<std::vector< ::apache::hadoop::hbase::thrift2::cpp2::THRegionLocation>> THBaseServiceAsyncClient::future_getAllRegionLocations(const std::string& table) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_getAllRegionLocations(rpcOptions, table);
}

folly::SemiFuture<std::vector< ::apache::hadoop::hbase::thrift2::cpp2::THRegionLocation>> THBaseServiceAsyncClient::semifuture_getAllRegionLocations(const std::string& table) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_getAllRegionLocations(rpcOptions, table);
}

folly::Future<std::vector< ::apache::hadoop::hbase::thrift2::cpp2::THRegionLocation>> THBaseServiceAsyncClient::future_getAllRegionLocations(apache::thrift::RpcOptions& rpcOptions, const std::string& table) {
  folly::Promise<std::vector< ::apache::hadoop::hbase::thrift2::cpp2::THRegionLocation>> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback<std::vector< ::apache::hadoop::hbase::thrift2::cpp2::THRegionLocation>>>(std::move(_promise), recv_wrapped_getAllRegionLocations, channel_);
  getAllRegionLocations(rpcOptions, std::move(callback), table);
  return _future;
}

folly::SemiFuture<std::vector< ::apache::hadoop::hbase::thrift2::cpp2::THRegionLocation>> THBaseServiceAsyncClient::semifuture_getAllRegionLocations(apache::thrift::RpcOptions& rpcOptions, const std::string& table) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_getAllRegionLocations, channel_);
  auto callback = std::move(callbackAndFuture.first);
  getAllRegionLocations(rpcOptions, std::move(callback), table);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair<std::vector< ::apache::hadoop::hbase::thrift2::cpp2::THRegionLocation>, std::unique_ptr<apache::thrift::transport::THeader>>> THBaseServiceAsyncClient::header_future_getAllRegionLocations(apache::thrift::RpcOptions& rpcOptions, const std::string& table) {
  folly::Promise<std::pair<std::vector< ::apache::hadoop::hbase::thrift2::cpp2::THRegionLocation>, std::unique_ptr<apache::thrift::transport::THeader>>> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback<std::vector< ::apache::hadoop::hbase::thrift2::cpp2::THRegionLocation>>>(std::move(_promise), recv_wrapped_getAllRegionLocations, channel_);
  getAllRegionLocations(rpcOptions, std::move(callback), table);
  return _future;
}

folly::SemiFuture<std::pair<std::vector< ::apache::hadoop::hbase::thrift2::cpp2::THRegionLocation>, std::unique_ptr<apache::thrift::transport::THeader>>> THBaseServiceAsyncClient::header_semifuture_getAllRegionLocations(apache::thrift::RpcOptions& rpcOptions, const std::string& table) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_getAllRegionLocations, channel_);
  auto callback = std::move(callbackAndFuture.first);
  getAllRegionLocations(rpcOptions, std::move(callback), table);
  return std::move(callbackAndFuture.second);
}

void THBaseServiceAsyncClient::getAllRegionLocations(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const std::string& table) {
  getAllRegionLocations(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), table);
}

folly::exception_wrapper THBaseServiceAsyncClient::recv_wrapped_getAllRegionLocations(std::vector< ::apache::hadoop::hbase::thrift2::cpp2::THRegionLocation>& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = THBaseService_getAllRegionLocations_presult;
  constexpr auto const fname = "getAllRegionLocations";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void THBaseServiceAsyncClient::recv_getAllRegionLocations(std::vector< ::apache::hadoop::hbase::thrift2::cpp2::THRegionLocation>& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_getAllRegionLocations(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void THBaseServiceAsyncClient::recv_instance_getAllRegionLocations(std::vector< ::apache::hadoop::hbase::thrift2::cpp2::THRegionLocation>& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_getAllRegionLocations(_return, state);
}

folly::exception_wrapper THBaseServiceAsyncClient::recv_instance_wrapped_getAllRegionLocations(std::vector< ::apache::hadoop::hbase::thrift2::cpp2::THRegionLocation>& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_getAllRegionLocations(_return, state);
}

void THBaseServiceAsyncClient::checkAndMutate(std::unique_ptr<apache::thrift::RequestCallback> callback, const std::string& table, const std::string& row, const std::string& family, const std::string& qualifier,  ::apache::hadoop::hbase::thrift2::cpp2::TCompareOp compareOp, const std::string& value, const  ::apache::hadoop::hbase::thrift2::cpp2::TRowMutations& rowMutations) {
  ::apache::thrift::RpcOptions rpcOptions;
  checkAndMutateImpl(false, rpcOptions, std::move(callback), table, row, family, qualifier, compareOp, value, rowMutations);
}

void THBaseServiceAsyncClient::checkAndMutate(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const std::string& table, const std::string& row, const std::string& family, const std::string& qualifier,  ::apache::hadoop::hbase::thrift2::cpp2::TCompareOp compareOp, const std::string& value, const  ::apache::hadoop::hbase::thrift2::cpp2::TRowMutations& rowMutations) {
  checkAndMutateImpl(false, rpcOptions, std::move(callback), table, row, family, qualifier, compareOp, value, rowMutations);
}

void THBaseServiceAsyncClient::checkAndMutateImpl(bool useSync, apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const std::string& table, const std::string& row, const std::string& family, const std::string& qualifier,  ::apache::hadoop::hbase::thrift2::cpp2::TCompareOp compareOp, const std::string& value, const  ::apache::hadoop::hbase::thrift2::cpp2::TRowMutations& rowMutations) {
  switch(getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      checkAndMutateT(&writer, useSync, rpcOptions, std::move(callback), table, row, family, qualifier, compareOp, value, rowMutations);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      checkAndMutateT(&writer, useSync, rpcOptions, std::move(callback), table, row, family, qualifier, compareOp, value, rowMutations);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

bool THBaseServiceAsyncClient::sync_checkAndMutate(const std::string& table, const std::string& row, const std::string& family, const std::string& qualifier,  ::apache::hadoop::hbase::thrift2::cpp2::TCompareOp compareOp, const std::string& value, const  ::apache::hadoop::hbase::thrift2::cpp2::TRowMutations& rowMutations) {
  ::apache::thrift::RpcOptions rpcOptions;
  return sync_checkAndMutate(rpcOptions, table, row, family, qualifier, compareOp, value, rowMutations);
}

bool THBaseServiceAsyncClient::sync_checkAndMutate(apache::thrift::RpcOptions& rpcOptions, const std::string& table, const std::string& row, const std::string& family, const std::string& qualifier,  ::apache::hadoop::hbase::thrift2::cpp2::TCompareOp compareOp, const std::string& value, const  ::apache::hadoop::hbase::thrift2::cpp2::TRowMutations& rowMutations) {
  apache::thrift::ClientReceiveState _returnState;
  auto callback = std::make_unique<apache::thrift::ClientSyncCallback>(
      &_returnState, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE);
  checkAndMutateImpl(true, rpcOptions, std::move(callback), table, row, family, qualifier, compareOp, value, rowMutations);
  SCOPE_EXIT {
    if (_returnState.header() && !_returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(_returnState.header()->releaseHeaders());
    }
  };
  if (!_returnState.buf()) {
    assert(!!_returnState.exception());
    _returnState.exception().throw_exception();
  }
  return recv_checkAndMutate(_returnState);
}

folly::Future<bool> THBaseServiceAsyncClient::future_checkAndMutate(const std::string& table, const std::string& row, const std::string& family, const std::string& qualifier,  ::apache::hadoop::hbase::thrift2::cpp2::TCompareOp compareOp, const std::string& value, const  ::apache::hadoop::hbase::thrift2::cpp2::TRowMutations& rowMutations) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_checkAndMutate(rpcOptions, table, row, family, qualifier, compareOp, value, rowMutations);
}

folly::SemiFuture<bool> THBaseServiceAsyncClient::semifuture_checkAndMutate(const std::string& table, const std::string& row, const std::string& family, const std::string& qualifier,  ::apache::hadoop::hbase::thrift2::cpp2::TCompareOp compareOp, const std::string& value, const  ::apache::hadoop::hbase::thrift2::cpp2::TRowMutations& rowMutations) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_checkAndMutate(rpcOptions, table, row, family, qualifier, compareOp, value, rowMutations);
}

folly::Future<bool> THBaseServiceAsyncClient::future_checkAndMutate(apache::thrift::RpcOptions& rpcOptions, const std::string& table, const std::string& row, const std::string& family, const std::string& qualifier,  ::apache::hadoop::hbase::thrift2::cpp2::TCompareOp compareOp, const std::string& value, const  ::apache::hadoop::hbase::thrift2::cpp2::TRowMutations& rowMutations) {
  folly::Promise<bool> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback<bool>>(std::move(_promise), recv_wrapped_checkAndMutate, channel_);
  checkAndMutate(rpcOptions, std::move(callback), table, row, family, qualifier, compareOp, value, rowMutations);
  return _future;
}

folly::SemiFuture<bool> THBaseServiceAsyncClient::semifuture_checkAndMutate(apache::thrift::RpcOptions& rpcOptions, const std::string& table, const std::string& row, const std::string& family, const std::string& qualifier,  ::apache::hadoop::hbase::thrift2::cpp2::TCompareOp compareOp, const std::string& value, const  ::apache::hadoop::hbase::thrift2::cpp2::TRowMutations& rowMutations) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_checkAndMutate, channel_);
  auto callback = std::move(callbackAndFuture.first);
  checkAndMutate(rpcOptions, std::move(callback), table, row, family, qualifier, compareOp, value, rowMutations);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair<bool, std::unique_ptr<apache::thrift::transport::THeader>>> THBaseServiceAsyncClient::header_future_checkAndMutate(apache::thrift::RpcOptions& rpcOptions, const std::string& table, const std::string& row, const std::string& family, const std::string& qualifier,  ::apache::hadoop::hbase::thrift2::cpp2::TCompareOp compareOp, const std::string& value, const  ::apache::hadoop::hbase::thrift2::cpp2::TRowMutations& rowMutations) {
  folly::Promise<std::pair<bool, std::unique_ptr<apache::thrift::transport::THeader>>> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback<bool>>(std::move(_promise), recv_wrapped_checkAndMutate, channel_);
  checkAndMutate(rpcOptions, std::move(callback), table, row, family, qualifier, compareOp, value, rowMutations);
  return _future;
}

folly::SemiFuture<std::pair<bool, std::unique_ptr<apache::thrift::transport::THeader>>> THBaseServiceAsyncClient::header_semifuture_checkAndMutate(apache::thrift::RpcOptions& rpcOptions, const std::string& table, const std::string& row, const std::string& family, const std::string& qualifier,  ::apache::hadoop::hbase::thrift2::cpp2::TCompareOp compareOp, const std::string& value, const  ::apache::hadoop::hbase::thrift2::cpp2::TRowMutations& rowMutations) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_checkAndMutate, channel_);
  auto callback = std::move(callbackAndFuture.first);
  checkAndMutate(rpcOptions, std::move(callback), table, row, family, qualifier, compareOp, value, rowMutations);
  return std::move(callbackAndFuture.second);
}

void THBaseServiceAsyncClient::checkAndMutate(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const std::string& table, const std::string& row, const std::string& family, const std::string& qualifier,  ::apache::hadoop::hbase::thrift2::cpp2::TCompareOp compareOp, const std::string& value, const  ::apache::hadoop::hbase::thrift2::cpp2::TRowMutations& rowMutations) {
  checkAndMutate(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), table, row, family, qualifier, compareOp, value, rowMutations);
}

folly::exception_wrapper THBaseServiceAsyncClient::recv_wrapped_checkAndMutate(bool& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = THBaseService_checkAndMutate_presult;
  constexpr auto const fname = "checkAndMutate";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

bool THBaseServiceAsyncClient::recv_checkAndMutate(::apache::thrift::ClientReceiveState& state) {
  bool _return;
  auto ew = recv_wrapped_checkAndMutate(_return, state);
  if (ew) {
    ew.throw_exception();
  }
  return _return;
}

bool THBaseServiceAsyncClient::recv_instance_checkAndMutate(::apache::thrift::ClientReceiveState& state) {
  return recv_checkAndMutate(state);
}

folly::exception_wrapper THBaseServiceAsyncClient::recv_instance_wrapped_checkAndMutate(bool& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_checkAndMutate(_return, state);
}

}}}}} // apache::hadoop::hbase::thrift2::cpp2
namespace apache { namespace thrift {

}} // apache::thrift
