/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "./gen-cpp2/hbase_types.h"
#include "./gen-cpp2/hbase_types.tcc"

#include <algorithm>
#include <folly/Indestructible.h>

#include "./gen-cpp2/hbase_data.h"

namespace apache { namespace hadoop { namespace hbase { namespace thrift2 { namespace cpp2 {

const _TDeleteType_EnumMapFactory::ValuesToNamesMapType _TDeleteType_VALUES_TO_NAMES = _TDeleteType_EnumMapFactory::makeValuesToNamesMap();
const _TDeleteType_EnumMapFactory::NamesToValuesMapType _TDeleteType_NAMES_TO_VALUES = _TDeleteType_EnumMapFactory::makeNamesToValuesMap();

}}}}} // apache::hadoop::hbase::thrift2::cpp2
namespace std {

} // std
namespace apache { namespace thrift {

template <> const std::size_t TEnumTraits< ::apache::hadoop::hbase::thrift2::cpp2::TDeleteType>::size = 2;
template <> const folly::Range<const  ::apache::hadoop::hbase::thrift2::cpp2::TDeleteType*> TEnumTraits< ::apache::hadoop::hbase::thrift2::cpp2::TDeleteType>::values = folly::range( ::apache::hadoop::hbase::thrift2::cpp2::_TDeleteTypeEnumDataStorage::values);
template <> const folly::Range<const folly::StringPiece*> TEnumTraits< ::apache::hadoop::hbase::thrift2::cpp2::TDeleteType>::names = folly::range( ::apache::hadoop::hbase::thrift2::cpp2::_TDeleteTypeEnumDataStorage::names);
template <> const char* TEnumTraits< ::apache::hadoop::hbase::thrift2::cpp2::TDeleteType>::findName( ::apache::hadoop::hbase::thrift2::cpp2::TDeleteType value) {
  static auto const map = folly::Indestructible< ::apache::hadoop::hbase::thrift2::cpp2::_TDeleteType_EnumMapFactory::ValuesToNamesMapType>{ ::apache::hadoop::hbase::thrift2::cpp2::_TDeleteType_EnumMapFactory::makeValuesToNamesMap()};
  return findName(*map, value);
}

template <> bool TEnumTraits< ::apache::hadoop::hbase::thrift2::cpp2::TDeleteType>::findValue(const char* name,  ::apache::hadoop::hbase::thrift2::cpp2::TDeleteType* outValue) {
  static auto const map = folly::Indestructible< ::apache::hadoop::hbase::thrift2::cpp2::_TDeleteType_EnumMapFactory::NamesToValuesMapType>{ ::apache::hadoop::hbase::thrift2::cpp2::_TDeleteType_EnumMapFactory::makeNamesToValuesMap()};
  return findValue(*map, name, outValue);
}

}} // apache::thrift
namespace apache { namespace hadoop { namespace hbase { namespace thrift2 { namespace cpp2 {

const _TDurability_EnumMapFactory::ValuesToNamesMapType _TDurability_VALUES_TO_NAMES = _TDurability_EnumMapFactory::makeValuesToNamesMap();
const _TDurability_EnumMapFactory::NamesToValuesMapType _TDurability_NAMES_TO_VALUES = _TDurability_EnumMapFactory::makeNamesToValuesMap();

}}}}} // apache::hadoop::hbase::thrift2::cpp2
namespace std {

} // std
namespace apache { namespace thrift {

template <> const std::size_t TEnumTraits< ::apache::hadoop::hbase::thrift2::cpp2::TDurability>::size = 4;
template <> const folly::Range<const  ::apache::hadoop::hbase::thrift2::cpp2::TDurability*> TEnumTraits< ::apache::hadoop::hbase::thrift2::cpp2::TDurability>::values = folly::range( ::apache::hadoop::hbase::thrift2::cpp2::_TDurabilityEnumDataStorage::values);
template <> const folly::Range<const folly::StringPiece*> TEnumTraits< ::apache::hadoop::hbase::thrift2::cpp2::TDurability>::names = folly::range( ::apache::hadoop::hbase::thrift2::cpp2::_TDurabilityEnumDataStorage::names);
template <> const char* TEnumTraits< ::apache::hadoop::hbase::thrift2::cpp2::TDurability>::findName( ::apache::hadoop::hbase::thrift2::cpp2::TDurability value) {
  static auto const map = folly::Indestructible< ::apache::hadoop::hbase::thrift2::cpp2::_TDurability_EnumMapFactory::ValuesToNamesMapType>{ ::apache::hadoop::hbase::thrift2::cpp2::_TDurability_EnumMapFactory::makeValuesToNamesMap()};
  return findName(*map, value);
}

template <> bool TEnumTraits< ::apache::hadoop::hbase::thrift2::cpp2::TDurability>::findValue(const char* name,  ::apache::hadoop::hbase::thrift2::cpp2::TDurability* outValue) {
  static auto const map = folly::Indestructible< ::apache::hadoop::hbase::thrift2::cpp2::_TDurability_EnumMapFactory::NamesToValuesMapType>{ ::apache::hadoop::hbase::thrift2::cpp2::_TDurability_EnumMapFactory::makeNamesToValuesMap()};
  return findValue(*map, name, outValue);
}

}} // apache::thrift
namespace apache { namespace hadoop { namespace hbase { namespace thrift2 { namespace cpp2 {

const _TCompareOp_EnumMapFactory::ValuesToNamesMapType _TCompareOp_VALUES_TO_NAMES = _TCompareOp_EnumMapFactory::makeValuesToNamesMap();
const _TCompareOp_EnumMapFactory::NamesToValuesMapType _TCompareOp_NAMES_TO_VALUES = _TCompareOp_EnumMapFactory::makeNamesToValuesMap();

}}}}} // apache::hadoop::hbase::thrift2::cpp2
namespace std {

} // std
namespace apache { namespace thrift {

template <> const std::size_t TEnumTraits< ::apache::hadoop::hbase::thrift2::cpp2::TCompareOp>::size = 7;
template <> const folly::Range<const  ::apache::hadoop::hbase::thrift2::cpp2::TCompareOp*> TEnumTraits< ::apache::hadoop::hbase::thrift2::cpp2::TCompareOp>::values = folly::range( ::apache::hadoop::hbase::thrift2::cpp2::_TCompareOpEnumDataStorage::values);
template <> const folly::Range<const folly::StringPiece*> TEnumTraits< ::apache::hadoop::hbase::thrift2::cpp2::TCompareOp>::names = folly::range( ::apache::hadoop::hbase::thrift2::cpp2::_TCompareOpEnumDataStorage::names);
template <> const char* TEnumTraits< ::apache::hadoop::hbase::thrift2::cpp2::TCompareOp>::findName( ::apache::hadoop::hbase::thrift2::cpp2::TCompareOp value) {
  static auto const map = folly::Indestructible< ::apache::hadoop::hbase::thrift2::cpp2::_TCompareOp_EnumMapFactory::ValuesToNamesMapType>{ ::apache::hadoop::hbase::thrift2::cpp2::_TCompareOp_EnumMapFactory::makeValuesToNamesMap()};
  return findName(*map, value);
}

template <> bool TEnumTraits< ::apache::hadoop::hbase::thrift2::cpp2::TCompareOp>::findValue(const char* name,  ::apache::hadoop::hbase::thrift2::cpp2::TCompareOp* outValue) {
  static auto const map = folly::Indestructible< ::apache::hadoop::hbase::thrift2::cpp2::_TCompareOp_EnumMapFactory::NamesToValuesMapType>{ ::apache::hadoop::hbase::thrift2::cpp2::_TCompareOp_EnumMapFactory::makeNamesToValuesMap()};
  return findValue(*map, name, outValue);
}

}} // apache::thrift

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits< ::apache::hadoop::hbase::thrift2::cpp2::TTimeRange>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) {
  if (false) {}
  else if (_fname == "minStamp") {
    fid = 1;
    _ftype = apache::thrift::protocol::T_I64;
  }
  else if (_fname == "maxStamp") {
    fid = 2;
    _ftype = apache::thrift::protocol::T_I64;
  }
}
void TccStructTraits< ::apache::hadoop::hbase::thrift2::cpp2::TColumn>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) {
  if (false) {}
  else if (_fname == "family") {
    fid = 1;
    _ftype = apache::thrift::protocol::T_STRING;
  }
  else if (_fname == "qualifier") {
    fid = 2;
    _ftype = apache::thrift::protocol::T_STRING;
  }
  else if (_fname == "timestamp") {
    fid = 3;
    _ftype = apache::thrift::protocol::T_I64;
  }
}
void TccStructTraits< ::apache::hadoop::hbase::thrift2::cpp2::TColumnValue>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) {
  if (false) {}
  else if (_fname == "family") {
    fid = 1;
    _ftype = apache::thrift::protocol::T_STRING;
  }
  else if (_fname == "qualifier") {
    fid = 2;
    _ftype = apache::thrift::protocol::T_STRING;
  }
  else if (_fname == "value") {
    fid = 3;
    _ftype = apache::thrift::protocol::T_STRING;
  }
  else if (_fname == "timestamp") {
    fid = 4;
    _ftype = apache::thrift::protocol::T_I64;
  }
  else if (_fname == "tags") {
    fid = 5;
    _ftype = apache::thrift::protocol::T_STRING;
  }
}
void TccStructTraits< ::apache::hadoop::hbase::thrift2::cpp2::TColumnIncrement>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) {
  if (false) {}
  else if (_fname == "family") {
    fid = 1;
    _ftype = apache::thrift::protocol::T_STRING;
  }
  else if (_fname == "qualifier") {
    fid = 2;
    _ftype = apache::thrift::protocol::T_STRING;
  }
  else if (_fname == "amount") {
    fid = 3;
    _ftype = apache::thrift::protocol::T_I64;
  }
}
void TccStructTraits< ::apache::hadoop::hbase::thrift2::cpp2::TResult>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) {
  if (false) {}
  else if (_fname == "row") {
    fid = 1;
    _ftype = apache::thrift::protocol::T_STRING;
  }
  else if (_fname == "columnValues") {
    fid = 2;
    _ftype = apache::thrift::protocol::T_LIST;
  }
}
void TccStructTraits< ::apache::hadoop::hbase::thrift2::cpp2::TAuthorization>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) {
  if (false) {}
  else if (_fname == "labels") {
    fid = 1;
    _ftype = apache::thrift::protocol::T_LIST;
  }
}
void TccStructTraits< ::apache::hadoop::hbase::thrift2::cpp2::TCellVisibility>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) {
  if (false) {}
  else if (_fname == "expression") {
    fid = 1;
    _ftype = apache::thrift::protocol::T_STRING;
  }
}
void TccStructTraits< ::apache::hadoop::hbase::thrift2::cpp2::TGet>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) {
  if (false) {}
  else if (_fname == "row") {
    fid = 1;
    _ftype = apache::thrift::protocol::T_STRING;
  }
  else if (_fname == "columns") {
    fid = 2;
    _ftype = apache::thrift::protocol::T_LIST;
  }
  else if (_fname == "timestamp") {
    fid = 3;
    _ftype = apache::thrift::protocol::T_I64;
  }
  else if (_fname == "timeRange") {
    fid = 4;
    _ftype = apache::thrift::protocol::T_STRUCT;
  }
  else if (_fname == "maxVersions") {
    fid = 5;
    _ftype = apache::thrift::protocol::T_I32;
  }
  else if (_fname == "filterString") {
    fid = 6;
    _ftype = apache::thrift::protocol::T_STRING;
  }
  else if (_fname == "attributes") {
    fid = 7;
    _ftype = apache::thrift::protocol::T_MAP;
  }
  else if (_fname == "authorizations") {
    fid = 8;
    _ftype = apache::thrift::protocol::T_STRUCT;
  }
}
void TccStructTraits< ::apache::hadoop::hbase::thrift2::cpp2::TPut>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) {
  if (false) {}
  else if (_fname == "row") {
    fid = 1;
    _ftype = apache::thrift::protocol::T_STRING;
  }
  else if (_fname == "columnValues") {
    fid = 2;
    _ftype = apache::thrift::protocol::T_LIST;
  }
  else if (_fname == "timestamp") {
    fid = 3;
    _ftype = apache::thrift::protocol::T_I64;
  }
  else if (_fname == "attributes") {
    fid = 5;
    _ftype = apache::thrift::protocol::T_MAP;
  }
  else if (_fname == "durability") {
    fid = 6;
    _ftype = apache::thrift::protocol::T_I32;
  }
  else if (_fname == "cellVisibility") {
    fid = 7;
    _ftype = apache::thrift::protocol::T_STRUCT;
  }
}
void TccStructTraits< ::apache::hadoop::hbase::thrift2::cpp2::TDelete>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) {
  if (false) {}
  else if (_fname == "row") {
    fid = 1;
    _ftype = apache::thrift::protocol::T_STRING;
  }
  else if (_fname == "columns") {
    fid = 2;
    _ftype = apache::thrift::protocol::T_LIST;
  }
  else if (_fname == "timestamp") {
    fid = 3;
    _ftype = apache::thrift::protocol::T_I64;
  }
  else if (_fname == "deleteType") {
    fid = 4;
    _ftype = apache::thrift::protocol::T_I32;
  }
  else if (_fname == "attributes") {
    fid = 6;
    _ftype = apache::thrift::protocol::T_MAP;
  }
  else if (_fname == "durability") {
    fid = 7;
    _ftype = apache::thrift::protocol::T_I32;
  }
}
void TccStructTraits< ::apache::hadoop::hbase::thrift2::cpp2::TIncrement>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) {
  if (false) {}
  else if (_fname == "row") {
    fid = 1;
    _ftype = apache::thrift::protocol::T_STRING;
  }
  else if (_fname == "columns") {
    fid = 2;
    _ftype = apache::thrift::protocol::T_LIST;
  }
  else if (_fname == "attributes") {
    fid = 4;
    _ftype = apache::thrift::protocol::T_MAP;
  }
  else if (_fname == "durability") {
    fid = 5;
    _ftype = apache::thrift::protocol::T_I32;
  }
  else if (_fname == "cellVisibility") {
    fid = 6;
    _ftype = apache::thrift::protocol::T_STRUCT;
  }
}
void TccStructTraits< ::apache::hadoop::hbase::thrift2::cpp2::TAppend>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) {
  if (false) {}
  else if (_fname == "row") {
    fid = 1;
    _ftype = apache::thrift::protocol::T_STRING;
  }
  else if (_fname == "columns") {
    fid = 2;
    _ftype = apache::thrift::protocol::T_LIST;
  }
  else if (_fname == "attributes") {
    fid = 3;
    _ftype = apache::thrift::protocol::T_MAP;
  }
  else if (_fname == "durability") {
    fid = 4;
    _ftype = apache::thrift::protocol::T_I32;
  }
  else if (_fname == "cellVisibility") {
    fid = 5;
    _ftype = apache::thrift::protocol::T_STRUCT;
  }
}
void TccStructTraits< ::apache::hadoop::hbase::thrift2::cpp2::TScan>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) {
  if (false) {}
  else if (_fname == "startRow") {
    fid = 1;
    _ftype = apache::thrift::protocol::T_STRING;
  }
  else if (_fname == "stopRow") {
    fid = 2;
    _ftype = apache::thrift::protocol::T_STRING;
  }
  else if (_fname == "columns") {
    fid = 3;
    _ftype = apache::thrift::protocol::T_LIST;
  }
  else if (_fname == "caching") {
    fid = 4;
    _ftype = apache::thrift::protocol::T_I32;
  }
  else if (_fname == "maxVersions") {
    fid = 5;
    _ftype = apache::thrift::protocol::T_I32;
  }
  else if (_fname == "timeRange") {
    fid = 6;
    _ftype = apache::thrift::protocol::T_STRUCT;
  }
  else if (_fname == "filterString") {
    fid = 7;
    _ftype = apache::thrift::protocol::T_STRING;
  }
  else if (_fname == "batchSize") {
    fid = 8;
    _ftype = apache::thrift::protocol::T_I32;
  }
  else if (_fname == "attributes") {
    fid = 9;
    _ftype = apache::thrift::protocol::T_MAP;
  }
  else if (_fname == "authorizations") {
    fid = 10;
    _ftype = apache::thrift::protocol::T_STRUCT;
  }
  else if (_fname == "reversed") {
    fid = 11;
    _ftype = apache::thrift::protocol::T_BOOL;
  }
  else if (_fname == "cacheBlocks") {
    fid = 12;
    _ftype = apache::thrift::protocol::T_BOOL;
  }
  else if (_fname == "colFamTimeRangeMap") {
    fid = 13;
    _ftype = apache::thrift::protocol::T_MAP;
  }
  else if (_fname == "small") {
    fid = 14;
    _ftype = apache::thrift::protocol::T_BOOL;
  }
}
void TccStructTraits< ::apache::hadoop::hbase::thrift2::cpp2::TMutation>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) {
  if (false) {}
  else if (_fname == "put") {
    fid = 1;
    _ftype = apache::thrift::protocol::T_STRUCT;
  }
  else if (_fname == "deleteSingle") {
    fid = 2;
    _ftype = apache::thrift::protocol::T_STRUCT;
  }
}
void TccStructTraits< ::apache::hadoop::hbase::thrift2::cpp2::TRowMutations>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) {
  if (false) {}
  else if (_fname == "row") {
    fid = 1;
    _ftype = apache::thrift::protocol::T_STRING;
  }
  else if (_fname == "mutations") {
    fid = 2;
    _ftype = apache::thrift::protocol::T_LIST;
  }
}
void TccStructTraits< ::apache::hadoop::hbase::thrift2::cpp2::THRegionInfo>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) {
  if (false) {}
  else if (_fname == "regionId") {
    fid = 1;
    _ftype = apache::thrift::protocol::T_I64;
  }
  else if (_fname == "tableName") {
    fid = 2;
    _ftype = apache::thrift::protocol::T_STRING;
  }
  else if (_fname == "startKey") {
    fid = 3;
    _ftype = apache::thrift::protocol::T_STRING;
  }
  else if (_fname == "endKey") {
    fid = 4;
    _ftype = apache::thrift::protocol::T_STRING;
  }
  else if (_fname == "offline") {
    fid = 5;
    _ftype = apache::thrift::protocol::T_BOOL;
  }
  else if (_fname == "split") {
    fid = 6;
    _ftype = apache::thrift::protocol::T_BOOL;
  }
  else if (_fname == "replicaId") {
    fid = 7;
    _ftype = apache::thrift::protocol::T_I32;
  }
}
void TccStructTraits< ::apache::hadoop::hbase::thrift2::cpp2::TServerName>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) {
  if (false) {}
  else if (_fname == "hostName") {
    fid = 1;
    _ftype = apache::thrift::protocol::T_STRING;
  }
  else if (_fname == "port") {
    fid = 2;
    _ftype = apache::thrift::protocol::T_I32;
  }
  else if (_fname == "startCode") {
    fid = 3;
    _ftype = apache::thrift::protocol::T_I64;
  }
}
void TccStructTraits< ::apache::hadoop::hbase::thrift2::cpp2::THRegionLocation>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) {
  if (false) {}
  else if (_fname == "serverName") {
    fid = 1;
    _ftype = apache::thrift::protocol::T_STRUCT;
  }
  else if (_fname == "regionInfo") {
    fid = 2;
    _ftype = apache::thrift::protocol::T_STRUCT;
  }
}
void TccStructTraits< ::apache::hadoop::hbase::thrift2::cpp2::TIOError>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) {
  if (false) {}
  else if (_fname == "message") {
    fid = 1;
    _ftype = apache::thrift::protocol::T_STRING;
  }
}
void TccStructTraits< ::apache::hadoop::hbase::thrift2::cpp2::TIllegalArgument>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) {
  if (false) {}
  else if (_fname == "message") {
    fid = 1;
    _ftype = apache::thrift::protocol::T_STRING;
  }
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace hadoop { namespace hbase { namespace thrift2 { namespace cpp2 {

TTimeRange::TTimeRange(apache::thrift::FragileConstructor, int64_t minStamp__arg, int64_t maxStamp__arg) :
    minStamp(std::move(minStamp__arg)),
    maxStamp(std::move(maxStamp__arg)) {}

void TTimeRange::__clear() {
  // clear all fields
  minStamp = 0;
  maxStamp = 0;
}

bool TTimeRange::operator==(const TTimeRange& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.minStamp == rhs.minStamp)) {
    return false;
  }
  if (!(lhs.maxStamp == rhs.maxStamp)) {
    return false;
  }
  return true;
}

bool TTimeRange::operator<(const TTimeRange& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.minStamp == rhs.minStamp)) {
    return lhs.minStamp < rhs.minStamp;
  }
  if (!(lhs.maxStamp == rhs.maxStamp)) {
    return lhs.maxStamp < rhs.maxStamp;
  }
  return false;
}


void swap(TTimeRange& a, TTimeRange& b) {
  using ::std::swap;
  swap(a.minStamp, b.minStamp);
  swap(a.maxStamp, b.maxStamp);
}

template void TTimeRange::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t TTimeRange::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t TTimeRange::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t TTimeRange::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void TTimeRange::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t TTimeRange::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t TTimeRange::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t TTimeRange::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}}}}} // apache::hadoop::hbase::thrift2::cpp2
namespace apache { namespace hadoop { namespace hbase { namespace thrift2 { namespace cpp2 {

TColumn::TColumn(apache::thrift::FragileConstructor, std::string family__arg, std::string qualifier__arg, int64_t timestamp__arg) :
    family(std::move(family__arg)),
    qualifier(std::move(qualifier__arg)),
    timestamp(std::move(timestamp__arg)) {
  __isset.qualifier = true;
  __isset.timestamp = true;
}

void TColumn::__clear() {
  // clear all fields
  family = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  qualifier = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  timestamp = 0;
  __isset = {};
}

bool TColumn::operator==(const TColumn& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.family, rhs.family)) {
    return false;
  }
  if (lhs.__isset.qualifier != rhs.__isset.qualifier) {
    return false;
  }
  if (lhs.__isset.qualifier) {
    if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.qualifier, rhs.qualifier)) {
      return false;
    }
  }
  if (lhs.__isset.timestamp != rhs.__isset.timestamp) {
    return false;
  }
  if (lhs.__isset.timestamp) {
    if (!(lhs.timestamp == rhs.timestamp)) {
      return false;
    }
  }
  return true;
}

bool TColumn::operator<(const TColumn& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.family, rhs.family)) {
    return apache::thrift::StringTraits<std::string>::isLess(lhs.family, rhs.family);
  }
  if (lhs.__isset.qualifier != rhs.__isset.qualifier) {
    return lhs.__isset.qualifier < rhs.__isset.qualifier;
  }
  if (lhs.__isset.qualifier) {
    if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.qualifier, rhs.qualifier)) {
      return apache::thrift::StringTraits<std::string>::isLess(lhs.qualifier, rhs.qualifier);
    }
  }
  if (lhs.__isset.timestamp != rhs.__isset.timestamp) {
    return lhs.__isset.timestamp < rhs.__isset.timestamp;
  }
  if (lhs.__isset.timestamp) {
    if (!(lhs.timestamp == rhs.timestamp)) {
      return lhs.timestamp < rhs.timestamp;
    }
  }
  return false;
}


void swap(TColumn& a, TColumn& b) {
  using ::std::swap;
  swap(a.family, b.family);
  swap(a.qualifier, b.qualifier);
  swap(a.timestamp, b.timestamp);
  swap(a.__isset, b.__isset);
}

template void TColumn::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t TColumn::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t TColumn::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t TColumn::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void TColumn::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t TColumn::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t TColumn::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t TColumn::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}}}}} // apache::hadoop::hbase::thrift2::cpp2
namespace apache { namespace hadoop { namespace hbase { namespace thrift2 { namespace cpp2 {

TColumnValue::TColumnValue() :
      timestamp(0) {}


TColumnValue::~TColumnValue() {}

TColumnValue::TColumnValue(apache::thrift::FragileConstructor, std::string family__arg, std::string qualifier__arg, std::string value__arg, int64_t timestamp__arg, std::string tags__arg) :
    family(std::move(family__arg)),
    qualifier(std::move(qualifier__arg)),
    value(std::move(value__arg)),
    timestamp(std::move(timestamp__arg)),
    tags(std::move(tags__arg)) {
  __isset.timestamp = true;
  __isset.tags = true;
}

void TColumnValue::__clear() {
  // clear all fields
  family = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  qualifier = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  value = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  timestamp = 0;
  tags = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  __isset = {};
}

bool TColumnValue::operator==(const TColumnValue& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.family, rhs.family)) {
    return false;
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.qualifier, rhs.qualifier)) {
    return false;
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.value, rhs.value)) {
    return false;
  }
  if (lhs.__isset.timestamp != rhs.__isset.timestamp) {
    return false;
  }
  if (lhs.__isset.timestamp) {
    if (!(lhs.timestamp == rhs.timestamp)) {
      return false;
    }
  }
  if (lhs.__isset.tags != rhs.__isset.tags) {
    return false;
  }
  if (lhs.__isset.tags) {
    if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.tags, rhs.tags)) {
      return false;
    }
  }
  return true;
}

bool TColumnValue::operator<(const TColumnValue& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.family, rhs.family)) {
    return apache::thrift::StringTraits<std::string>::isLess(lhs.family, rhs.family);
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.qualifier, rhs.qualifier)) {
    return apache::thrift::StringTraits<std::string>::isLess(lhs.qualifier, rhs.qualifier);
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.value, rhs.value)) {
    return apache::thrift::StringTraits<std::string>::isLess(lhs.value, rhs.value);
  }
  if (lhs.__isset.timestamp != rhs.__isset.timestamp) {
    return lhs.__isset.timestamp < rhs.__isset.timestamp;
  }
  if (lhs.__isset.timestamp) {
    if (!(lhs.timestamp == rhs.timestamp)) {
      return lhs.timestamp < rhs.timestamp;
    }
  }
  if (lhs.__isset.tags != rhs.__isset.tags) {
    return lhs.__isset.tags < rhs.__isset.tags;
  }
  if (lhs.__isset.tags) {
    if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.tags, rhs.tags)) {
      return apache::thrift::StringTraits<std::string>::isLess(lhs.tags, rhs.tags);
    }
  }
  return false;
}


void swap(TColumnValue& a, TColumnValue& b) {
  using ::std::swap;
  swap(a.family, b.family);
  swap(a.qualifier, b.qualifier);
  swap(a.value, b.value);
  swap(a.timestamp, b.timestamp);
  swap(a.tags, b.tags);
  swap(a.__isset, b.__isset);
}

template void TColumnValue::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t TColumnValue::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t TColumnValue::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t TColumnValue::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void TColumnValue::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t TColumnValue::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t TColumnValue::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t TColumnValue::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}}}}} // apache::hadoop::hbase::thrift2::cpp2
namespace apache { namespace hadoop { namespace hbase { namespace thrift2 { namespace cpp2 {

TColumnIncrement::TColumnIncrement(apache::thrift::FragileConstructor, std::string family__arg, std::string qualifier__arg, int64_t amount__arg) :
    family(std::move(family__arg)),
    qualifier(std::move(qualifier__arg)),
    amount(std::move(amount__arg)) {
  __isset.amount = true;
}

void TColumnIncrement::__clear() {
  // clear all fields
  family = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  qualifier = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  amount = 1LL;
  __isset = {};
}

bool TColumnIncrement::operator==(const TColumnIncrement& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.family, rhs.family)) {
    return false;
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.qualifier, rhs.qualifier)) {
    return false;
  }
  if (lhs.__isset.amount != rhs.__isset.amount) {
    return false;
  }
  if (lhs.__isset.amount) {
    if (!(lhs.amount == rhs.amount)) {
      return false;
    }
  }
  return true;
}

bool TColumnIncrement::operator<(const TColumnIncrement& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.family, rhs.family)) {
    return apache::thrift::StringTraits<std::string>::isLess(lhs.family, rhs.family);
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.qualifier, rhs.qualifier)) {
    return apache::thrift::StringTraits<std::string>::isLess(lhs.qualifier, rhs.qualifier);
  }
  if (lhs.__isset.amount != rhs.__isset.amount) {
    return lhs.__isset.amount < rhs.__isset.amount;
  }
  if (lhs.__isset.amount) {
    if (!(lhs.amount == rhs.amount)) {
      return lhs.amount < rhs.amount;
    }
  }
  return false;
}


void swap(TColumnIncrement& a, TColumnIncrement& b) {
  using ::std::swap;
  swap(a.family, b.family);
  swap(a.qualifier, b.qualifier);
  swap(a.amount, b.amount);
  swap(a.__isset, b.__isset);
}

template void TColumnIncrement::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t TColumnIncrement::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t TColumnIncrement::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t TColumnIncrement::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void TColumnIncrement::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t TColumnIncrement::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t TColumnIncrement::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t TColumnIncrement::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}}}}} // apache::hadoop::hbase::thrift2::cpp2
namespace apache { namespace hadoop { namespace hbase { namespace thrift2 { namespace cpp2 {

TResult::TResult(apache::thrift::FragileConstructor, std::string row__arg, std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TColumnValue> columnValues__arg) :
    row(std::move(row__arg)),
    columnValues(std::move(columnValues__arg)) {
  __isset.row = true;
}

void TResult::__clear() {
  // clear all fields
  row = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  columnValues.clear();
  __isset = {};
}

bool TResult::operator==(const TResult& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.__isset.row != rhs.__isset.row) {
    return false;
  }
  if (lhs.__isset.row) {
    if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.row, rhs.row)) {
      return false;
    }
  }
  if (!(lhs.columnValues == rhs.columnValues)) {
    return false;
  }
  return true;
}

bool TResult::operator<(const TResult& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.__isset.row != rhs.__isset.row) {
    return lhs.__isset.row < rhs.__isset.row;
  }
  if (lhs.__isset.row) {
    if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.row, rhs.row)) {
      return apache::thrift::StringTraits<std::string>::isLess(lhs.row, rhs.row);
    }
  }
  if (!(lhs.columnValues == rhs.columnValues)) {
    return lhs.columnValues < rhs.columnValues;
  }
  return false;
}

const std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TColumnValue>& TResult::get_columnValues() const& {
  return columnValues;
}

std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TColumnValue> TResult::get_columnValues() && {
  return std::move(columnValues);
}


void swap(TResult& a, TResult& b) {
  using ::std::swap;
  swap(a.row, b.row);
  swap(a.columnValues, b.columnValues);
  swap(a.__isset, b.__isset);
}

template void TResult::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t TResult::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t TResult::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t TResult::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void TResult::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t TResult::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t TResult::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t TResult::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}}}}} // apache::hadoop::hbase::thrift2::cpp2
namespace apache { namespace hadoop { namespace hbase { namespace thrift2 { namespace cpp2 {

TAuthorization::TAuthorization(apache::thrift::FragileConstructor, std::vector<std::string> labels__arg) :
    labels(std::move(labels__arg)) {
  __isset.labels = true;
}

void TAuthorization::__clear() {
  // clear all fields
  labels.clear();
  __isset = {};
}

bool TAuthorization::operator==(const TAuthorization& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.__isset.labels != rhs.__isset.labels) {
    return false;
  }
  if (lhs.__isset.labels) {
    if (!(lhs.labels == rhs.labels)) {
      return false;
    }
  }
  return true;
}

bool TAuthorization::operator<(const TAuthorization& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.__isset.labels != rhs.__isset.labels) {
    return lhs.__isset.labels < rhs.__isset.labels;
  }
  if (lhs.__isset.labels) {
    if (!(lhs.labels == rhs.labels)) {
      return lhs.labels < rhs.labels;
    }
  }
  return false;
}

const std::vector<std::string>* TAuthorization::get_labels() const& {
  return __isset.labels ? std::addressof(labels) : nullptr;
}

std::vector<std::string>* TAuthorization::get_labels() & {
  return __isset.labels ? std::addressof(labels) : nullptr;
}


void swap(TAuthorization& a, TAuthorization& b) {
  using ::std::swap;
  swap(a.labels, b.labels);
  swap(a.__isset, b.__isset);
}

template void TAuthorization::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t TAuthorization::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t TAuthorization::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t TAuthorization::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void TAuthorization::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t TAuthorization::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t TAuthorization::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t TAuthorization::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}}}}} // apache::hadoop::hbase::thrift2::cpp2
namespace apache { namespace hadoop { namespace hbase { namespace thrift2 { namespace cpp2 {

TCellVisibility::TCellVisibility(apache::thrift::FragileConstructor, std::string expression__arg) :
    expression(std::move(expression__arg)) {
  __isset.expression = true;
}

void TCellVisibility::__clear() {
  // clear all fields
  expression = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  __isset = {};
}

bool TCellVisibility::operator==(const TCellVisibility& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.__isset.expression != rhs.__isset.expression) {
    return false;
  }
  if (lhs.__isset.expression) {
    if (!(lhs.expression == rhs.expression)) {
      return false;
    }
  }
  return true;
}

bool TCellVisibility::operator<(const TCellVisibility& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.__isset.expression != rhs.__isset.expression) {
    return lhs.__isset.expression < rhs.__isset.expression;
  }
  if (lhs.__isset.expression) {
    if (!(lhs.expression == rhs.expression)) {
      return lhs.expression < rhs.expression;
    }
  }
  return false;
}


void swap(TCellVisibility& a, TCellVisibility& b) {
  using ::std::swap;
  swap(a.expression, b.expression);
  swap(a.__isset, b.__isset);
}

template void TCellVisibility::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t TCellVisibility::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t TCellVisibility::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t TCellVisibility::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void TCellVisibility::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t TCellVisibility::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t TCellVisibility::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t TCellVisibility::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}}}}} // apache::hadoop::hbase::thrift2::cpp2
namespace apache { namespace hadoop { namespace hbase { namespace thrift2 { namespace cpp2 {

TGet::TGet() :
      timestamp(0),
      maxVersions(0) {}


TGet::~TGet() {}

TGet::TGet(apache::thrift::FragileConstructor, std::string row__arg, std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TColumn> columns__arg, int64_t timestamp__arg,  ::apache::hadoop::hbase::thrift2::cpp2::TTimeRange timeRange__arg, int32_t maxVersions__arg, std::string filterString__arg, std::map<std::string, std::string> attributes__arg,  ::apache::hadoop::hbase::thrift2::cpp2::TAuthorization authorizations__arg) :
    row(std::move(row__arg)),
    columns(std::move(columns__arg)),
    timestamp(std::move(timestamp__arg)),
    timeRange(std::move(timeRange__arg)),
    maxVersions(std::move(maxVersions__arg)),
    filterString(std::move(filterString__arg)),
    attributes(std::move(attributes__arg)),
    authorizations(std::move(authorizations__arg)) {
  __isset.columns = true;
  __isset.timestamp = true;
  __isset.timeRange = true;
  __isset.maxVersions = true;
  __isset.filterString = true;
  __isset.attributes = true;
  __isset.authorizations = true;
}

void TGet::__clear() {
  // clear all fields
  row = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  columns.clear();
  timestamp = 0;
  ::apache::thrift::Cpp2Ops<  ::apache::hadoop::hbase::thrift2::cpp2::TTimeRange>::clear(&timeRange);
  maxVersions = 0;
  filterString = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  attributes.clear();
  ::apache::thrift::Cpp2Ops<  ::apache::hadoop::hbase::thrift2::cpp2::TAuthorization>::clear(&authorizations);
  __isset = {};
}

bool TGet::operator==(const TGet& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.row, rhs.row)) {
    return false;
  }
  if (lhs.__isset.columns != rhs.__isset.columns) {
    return false;
  }
  if (lhs.__isset.columns) {
    if (!(lhs.columns == rhs.columns)) {
      return false;
    }
  }
  if (lhs.__isset.timestamp != rhs.__isset.timestamp) {
    return false;
  }
  if (lhs.__isset.timestamp) {
    if (!(lhs.timestamp == rhs.timestamp)) {
      return false;
    }
  }
  if (lhs.__isset.timeRange != rhs.__isset.timeRange) {
    return false;
  }
  if (lhs.__isset.timeRange) {
    if (!(lhs.timeRange == rhs.timeRange)) {
      return false;
    }
  }
  if (lhs.__isset.maxVersions != rhs.__isset.maxVersions) {
    return false;
  }
  if (lhs.__isset.maxVersions) {
    if (!(lhs.maxVersions == rhs.maxVersions)) {
      return false;
    }
  }
  if (lhs.__isset.filterString != rhs.__isset.filterString) {
    return false;
  }
  if (lhs.__isset.filterString) {
    if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.filterString, rhs.filterString)) {
      return false;
    }
  }
  if (lhs.__isset.attributes != rhs.__isset.attributes) {
    return false;
  }
  if (lhs.__isset.attributes) {
    if (!(lhs.attributes == rhs.attributes)) {
      return false;
    }
  }
  if (lhs.__isset.authorizations != rhs.__isset.authorizations) {
    return false;
  }
  if (lhs.__isset.authorizations) {
    if (!(lhs.authorizations == rhs.authorizations)) {
      return false;
    }
  }
  return true;
}

bool TGet::operator<(const TGet& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.row, rhs.row)) {
    return apache::thrift::StringTraits<std::string>::isLess(lhs.row, rhs.row);
  }
  if (lhs.__isset.columns != rhs.__isset.columns) {
    return lhs.__isset.columns < rhs.__isset.columns;
  }
  if (lhs.__isset.columns) {
    if (!(lhs.columns == rhs.columns)) {
      return lhs.columns < rhs.columns;
    }
  }
  if (lhs.__isset.timestamp != rhs.__isset.timestamp) {
    return lhs.__isset.timestamp < rhs.__isset.timestamp;
  }
  if (lhs.__isset.timestamp) {
    if (!(lhs.timestamp == rhs.timestamp)) {
      return lhs.timestamp < rhs.timestamp;
    }
  }
  if (lhs.__isset.timeRange != rhs.__isset.timeRange) {
    return lhs.__isset.timeRange < rhs.__isset.timeRange;
  }
  if (lhs.__isset.timeRange) {
    if (!(lhs.timeRange == rhs.timeRange)) {
      return lhs.timeRange < rhs.timeRange;
    }
  }
  if (lhs.__isset.maxVersions != rhs.__isset.maxVersions) {
    return lhs.__isset.maxVersions < rhs.__isset.maxVersions;
  }
  if (lhs.__isset.maxVersions) {
    if (!(lhs.maxVersions == rhs.maxVersions)) {
      return lhs.maxVersions < rhs.maxVersions;
    }
  }
  if (lhs.__isset.filterString != rhs.__isset.filterString) {
    return lhs.__isset.filterString < rhs.__isset.filterString;
  }
  if (lhs.__isset.filterString) {
    if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.filterString, rhs.filterString)) {
      return apache::thrift::StringTraits<std::string>::isLess(lhs.filterString, rhs.filterString);
    }
  }
  if (lhs.__isset.attributes != rhs.__isset.attributes) {
    return lhs.__isset.attributes < rhs.__isset.attributes;
  }
  if (lhs.__isset.attributes) {
    if (!(lhs.attributes == rhs.attributes)) {
      return lhs.attributes < rhs.attributes;
    }
  }
  if (lhs.__isset.authorizations != rhs.__isset.authorizations) {
    return lhs.__isset.authorizations < rhs.__isset.authorizations;
  }
  if (lhs.__isset.authorizations) {
    if (!(lhs.authorizations == rhs.authorizations)) {
      return lhs.authorizations < rhs.authorizations;
    }
  }
  return false;
}

const std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TColumn>* TGet::get_columns() const& {
  return __isset.columns ? std::addressof(columns) : nullptr;
}

std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TColumn>* TGet::get_columns() & {
  return __isset.columns ? std::addressof(columns) : nullptr;
}

const  ::apache::hadoop::hbase::thrift2::cpp2::TTimeRange* TGet::get_timeRange() const& {
  return __isset.timeRange ? std::addressof(timeRange) : nullptr;
}

 ::apache::hadoop::hbase::thrift2::cpp2::TTimeRange* TGet::get_timeRange() & {
  return __isset.timeRange ? std::addressof(timeRange) : nullptr;
}

const std::map<std::string, std::string>* TGet::get_attributes() const& {
  return __isset.attributes ? std::addressof(attributes) : nullptr;
}

std::map<std::string, std::string>* TGet::get_attributes() & {
  return __isset.attributes ? std::addressof(attributes) : nullptr;
}

const  ::apache::hadoop::hbase::thrift2::cpp2::TAuthorization* TGet::get_authorizations() const& {
  return __isset.authorizations ? std::addressof(authorizations) : nullptr;
}

 ::apache::hadoop::hbase::thrift2::cpp2::TAuthorization* TGet::get_authorizations() & {
  return __isset.authorizations ? std::addressof(authorizations) : nullptr;
}


void swap(TGet& a, TGet& b) {
  using ::std::swap;
  swap(a.row, b.row);
  swap(a.columns, b.columns);
  swap(a.timestamp, b.timestamp);
  swap(a.timeRange, b.timeRange);
  swap(a.maxVersions, b.maxVersions);
  swap(a.filterString, b.filterString);
  swap(a.attributes, b.attributes);
  swap(a.authorizations, b.authorizations);
  swap(a.__isset, b.__isset);
}

template void TGet::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t TGet::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t TGet::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t TGet::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void TGet::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t TGet::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t TGet::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t TGet::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}}}}} // apache::hadoop::hbase::thrift2::cpp2
namespace apache { namespace hadoop { namespace hbase { namespace thrift2 { namespace cpp2 {

TPut::TPut() :
      timestamp(0),
      durability(static_cast< ::apache::hadoop::hbase::thrift2::cpp2::TDurability>(0)) {}


TPut::~TPut() {}

TPut::TPut(apache::thrift::FragileConstructor, std::string row__arg, std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TColumnValue> columnValues__arg, int64_t timestamp__arg, std::map<std::string, std::string> attributes__arg,  ::apache::hadoop::hbase::thrift2::cpp2::TDurability durability__arg,  ::apache::hadoop::hbase::thrift2::cpp2::TCellVisibility cellVisibility__arg) :
    row(std::move(row__arg)),
    columnValues(std::move(columnValues__arg)),
    timestamp(std::move(timestamp__arg)),
    attributes(std::move(attributes__arg)),
    durability(std::move(durability__arg)),
    cellVisibility(std::move(cellVisibility__arg)) {
  __isset.timestamp = true;
  __isset.attributes = true;
  __isset.durability = true;
  __isset.cellVisibility = true;
}

void TPut::__clear() {
  // clear all fields
  row = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  columnValues.clear();
  timestamp = 0;
  attributes.clear();
  durability = static_cast< ::apache::hadoop::hbase::thrift2::cpp2::TDurability>(0);
  ::apache::thrift::Cpp2Ops<  ::apache::hadoop::hbase::thrift2::cpp2::TCellVisibility>::clear(&cellVisibility);
  __isset = {};
}

bool TPut::operator==(const TPut& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.row, rhs.row)) {
    return false;
  }
  if (!(lhs.columnValues == rhs.columnValues)) {
    return false;
  }
  if (lhs.__isset.timestamp != rhs.__isset.timestamp) {
    return false;
  }
  if (lhs.__isset.timestamp) {
    if (!(lhs.timestamp == rhs.timestamp)) {
      return false;
    }
  }
  if (lhs.__isset.attributes != rhs.__isset.attributes) {
    return false;
  }
  if (lhs.__isset.attributes) {
    if (!(lhs.attributes == rhs.attributes)) {
      return false;
    }
  }
  if (lhs.__isset.durability != rhs.__isset.durability) {
    return false;
  }
  if (lhs.__isset.durability) {
    if (!(lhs.durability == rhs.durability)) {
      return false;
    }
  }
  if (lhs.__isset.cellVisibility != rhs.__isset.cellVisibility) {
    return false;
  }
  if (lhs.__isset.cellVisibility) {
    if (!(lhs.cellVisibility == rhs.cellVisibility)) {
      return false;
    }
  }
  return true;
}

bool TPut::operator<(const TPut& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.row, rhs.row)) {
    return apache::thrift::StringTraits<std::string>::isLess(lhs.row, rhs.row);
  }
  if (!(lhs.columnValues == rhs.columnValues)) {
    return lhs.columnValues < rhs.columnValues;
  }
  if (lhs.__isset.timestamp != rhs.__isset.timestamp) {
    return lhs.__isset.timestamp < rhs.__isset.timestamp;
  }
  if (lhs.__isset.timestamp) {
    if (!(lhs.timestamp == rhs.timestamp)) {
      return lhs.timestamp < rhs.timestamp;
    }
  }
  if (lhs.__isset.attributes != rhs.__isset.attributes) {
    return lhs.__isset.attributes < rhs.__isset.attributes;
  }
  if (lhs.__isset.attributes) {
    if (!(lhs.attributes == rhs.attributes)) {
      return lhs.attributes < rhs.attributes;
    }
  }
  if (lhs.__isset.durability != rhs.__isset.durability) {
    return lhs.__isset.durability < rhs.__isset.durability;
  }
  if (lhs.__isset.durability) {
    if (!(lhs.durability == rhs.durability)) {
      return lhs.durability < rhs.durability;
    }
  }
  if (lhs.__isset.cellVisibility != rhs.__isset.cellVisibility) {
    return lhs.__isset.cellVisibility < rhs.__isset.cellVisibility;
  }
  if (lhs.__isset.cellVisibility) {
    if (!(lhs.cellVisibility == rhs.cellVisibility)) {
      return lhs.cellVisibility < rhs.cellVisibility;
    }
  }
  return false;
}

const std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TColumnValue>& TPut::get_columnValues() const& {
  return columnValues;
}

std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TColumnValue> TPut::get_columnValues() && {
  return std::move(columnValues);
}

const std::map<std::string, std::string>* TPut::get_attributes() const& {
  return __isset.attributes ? std::addressof(attributes) : nullptr;
}

std::map<std::string, std::string>* TPut::get_attributes() & {
  return __isset.attributes ? std::addressof(attributes) : nullptr;
}

const  ::apache::hadoop::hbase::thrift2::cpp2::TCellVisibility* TPut::get_cellVisibility() const& {
  return __isset.cellVisibility ? std::addressof(cellVisibility) : nullptr;
}

 ::apache::hadoop::hbase::thrift2::cpp2::TCellVisibility* TPut::get_cellVisibility() & {
  return __isset.cellVisibility ? std::addressof(cellVisibility) : nullptr;
}


void swap(TPut& a, TPut& b) {
  using ::std::swap;
  swap(a.row, b.row);
  swap(a.columnValues, b.columnValues);
  swap(a.timestamp, b.timestamp);
  swap(a.attributes, b.attributes);
  swap(a.durability, b.durability);
  swap(a.cellVisibility, b.cellVisibility);
  swap(a.__isset, b.__isset);
}

template void TPut::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t TPut::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t TPut::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t TPut::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void TPut::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t TPut::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t TPut::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t TPut::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}}}}} // apache::hadoop::hbase::thrift2::cpp2
namespace apache { namespace hadoop { namespace hbase { namespace thrift2 { namespace cpp2 {

TDelete::TDelete() :
      timestamp(0),
      deleteType( ::apache::hadoop::hbase::thrift2::cpp2::TDeleteType::DELETE_COLUMNS),
      durability(static_cast< ::apache::hadoop::hbase::thrift2::cpp2::TDurability>(0)) {}


TDelete::~TDelete() {}

TDelete::TDelete(apache::thrift::FragileConstructor, std::string row__arg, std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TColumn> columns__arg, int64_t timestamp__arg,  ::apache::hadoop::hbase::thrift2::cpp2::TDeleteType deleteType__arg, std::map<std::string, std::string> attributes__arg,  ::apache::hadoop::hbase::thrift2::cpp2::TDurability durability__arg) :
    row(std::move(row__arg)),
    columns(std::move(columns__arg)),
    timestamp(std::move(timestamp__arg)),
    deleteType(std::move(deleteType__arg)),
    attributes(std::move(attributes__arg)),
    durability(std::move(durability__arg)) {
  __isset.columns = true;
  __isset.timestamp = true;
  __isset.deleteType = true;
  __isset.attributes = true;
  __isset.durability = true;
}

void TDelete::__clear() {
  // clear all fields
  row = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  columns.clear();
  timestamp = 0;
  deleteType =  ::apache::hadoop::hbase::thrift2::cpp2::TDeleteType::DELETE_COLUMNS;
  attributes.clear();
  durability = static_cast< ::apache::hadoop::hbase::thrift2::cpp2::TDurability>(0);
  __isset = {};
}

bool TDelete::operator==(const TDelete& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.row, rhs.row)) {
    return false;
  }
  if (lhs.__isset.columns != rhs.__isset.columns) {
    return false;
  }
  if (lhs.__isset.columns) {
    if (!(lhs.columns == rhs.columns)) {
      return false;
    }
  }
  if (lhs.__isset.timestamp != rhs.__isset.timestamp) {
    return false;
  }
  if (lhs.__isset.timestamp) {
    if (!(lhs.timestamp == rhs.timestamp)) {
      return false;
    }
  }
  if (lhs.__isset.deleteType != rhs.__isset.deleteType) {
    return false;
  }
  if (lhs.__isset.deleteType) {
    if (!(lhs.deleteType == rhs.deleteType)) {
      return false;
    }
  }
  if (lhs.__isset.attributes != rhs.__isset.attributes) {
    return false;
  }
  if (lhs.__isset.attributes) {
    if (!(lhs.attributes == rhs.attributes)) {
      return false;
    }
  }
  if (lhs.__isset.durability != rhs.__isset.durability) {
    return false;
  }
  if (lhs.__isset.durability) {
    if (!(lhs.durability == rhs.durability)) {
      return false;
    }
  }
  return true;
}

bool TDelete::operator<(const TDelete& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.row, rhs.row)) {
    return apache::thrift::StringTraits<std::string>::isLess(lhs.row, rhs.row);
  }
  if (lhs.__isset.columns != rhs.__isset.columns) {
    return lhs.__isset.columns < rhs.__isset.columns;
  }
  if (lhs.__isset.columns) {
    if (!(lhs.columns == rhs.columns)) {
      return lhs.columns < rhs.columns;
    }
  }
  if (lhs.__isset.timestamp != rhs.__isset.timestamp) {
    return lhs.__isset.timestamp < rhs.__isset.timestamp;
  }
  if (lhs.__isset.timestamp) {
    if (!(lhs.timestamp == rhs.timestamp)) {
      return lhs.timestamp < rhs.timestamp;
    }
  }
  if (lhs.__isset.deleteType != rhs.__isset.deleteType) {
    return lhs.__isset.deleteType < rhs.__isset.deleteType;
  }
  if (lhs.__isset.deleteType) {
    if (!(lhs.deleteType == rhs.deleteType)) {
      return lhs.deleteType < rhs.deleteType;
    }
  }
  if (lhs.__isset.attributes != rhs.__isset.attributes) {
    return lhs.__isset.attributes < rhs.__isset.attributes;
  }
  if (lhs.__isset.attributes) {
    if (!(lhs.attributes == rhs.attributes)) {
      return lhs.attributes < rhs.attributes;
    }
  }
  if (lhs.__isset.durability != rhs.__isset.durability) {
    return lhs.__isset.durability < rhs.__isset.durability;
  }
  if (lhs.__isset.durability) {
    if (!(lhs.durability == rhs.durability)) {
      return lhs.durability < rhs.durability;
    }
  }
  return false;
}

const std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TColumn>* TDelete::get_columns() const& {
  return __isset.columns ? std::addressof(columns) : nullptr;
}

std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TColumn>* TDelete::get_columns() & {
  return __isset.columns ? std::addressof(columns) : nullptr;
}

const std::map<std::string, std::string>* TDelete::get_attributes() const& {
  return __isset.attributes ? std::addressof(attributes) : nullptr;
}

std::map<std::string, std::string>* TDelete::get_attributes() & {
  return __isset.attributes ? std::addressof(attributes) : nullptr;
}


void swap(TDelete& a, TDelete& b) {
  using ::std::swap;
  swap(a.row, b.row);
  swap(a.columns, b.columns);
  swap(a.timestamp, b.timestamp);
  swap(a.deleteType, b.deleteType);
  swap(a.attributes, b.attributes);
  swap(a.durability, b.durability);
  swap(a.__isset, b.__isset);
}

template void TDelete::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t TDelete::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t TDelete::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t TDelete::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void TDelete::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t TDelete::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t TDelete::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t TDelete::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}}}}} // apache::hadoop::hbase::thrift2::cpp2
namespace apache { namespace hadoop { namespace hbase { namespace thrift2 { namespace cpp2 {

TIncrement::TIncrement() :
      durability(static_cast< ::apache::hadoop::hbase::thrift2::cpp2::TDurability>(0)) {}


TIncrement::~TIncrement() {}

TIncrement::TIncrement(apache::thrift::FragileConstructor, std::string row__arg, std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TColumnIncrement> columns__arg, std::map<std::string, std::string> attributes__arg,  ::apache::hadoop::hbase::thrift2::cpp2::TDurability durability__arg,  ::apache::hadoop::hbase::thrift2::cpp2::TCellVisibility cellVisibility__arg) :
    row(std::move(row__arg)),
    columns(std::move(columns__arg)),
    attributes(std::move(attributes__arg)),
    durability(std::move(durability__arg)),
    cellVisibility(std::move(cellVisibility__arg)) {
  __isset.attributes = true;
  __isset.durability = true;
  __isset.cellVisibility = true;
}

void TIncrement::__clear() {
  // clear all fields
  row = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  columns.clear();
  attributes.clear();
  durability = static_cast< ::apache::hadoop::hbase::thrift2::cpp2::TDurability>(0);
  ::apache::thrift::Cpp2Ops<  ::apache::hadoop::hbase::thrift2::cpp2::TCellVisibility>::clear(&cellVisibility);
  __isset = {};
}

bool TIncrement::operator==(const TIncrement& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.row, rhs.row)) {
    return false;
  }
  if (!(lhs.columns == rhs.columns)) {
    return false;
  }
  if (lhs.__isset.attributes != rhs.__isset.attributes) {
    return false;
  }
  if (lhs.__isset.attributes) {
    if (!(lhs.attributes == rhs.attributes)) {
      return false;
    }
  }
  if (lhs.__isset.durability != rhs.__isset.durability) {
    return false;
  }
  if (lhs.__isset.durability) {
    if (!(lhs.durability == rhs.durability)) {
      return false;
    }
  }
  if (lhs.__isset.cellVisibility != rhs.__isset.cellVisibility) {
    return false;
  }
  if (lhs.__isset.cellVisibility) {
    if (!(lhs.cellVisibility == rhs.cellVisibility)) {
      return false;
    }
  }
  return true;
}

bool TIncrement::operator<(const TIncrement& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.row, rhs.row)) {
    return apache::thrift::StringTraits<std::string>::isLess(lhs.row, rhs.row);
  }
  if (!(lhs.columns == rhs.columns)) {
    return lhs.columns < rhs.columns;
  }
  if (lhs.__isset.attributes != rhs.__isset.attributes) {
    return lhs.__isset.attributes < rhs.__isset.attributes;
  }
  if (lhs.__isset.attributes) {
    if (!(lhs.attributes == rhs.attributes)) {
      return lhs.attributes < rhs.attributes;
    }
  }
  if (lhs.__isset.durability != rhs.__isset.durability) {
    return lhs.__isset.durability < rhs.__isset.durability;
  }
  if (lhs.__isset.durability) {
    if (!(lhs.durability == rhs.durability)) {
      return lhs.durability < rhs.durability;
    }
  }
  if (lhs.__isset.cellVisibility != rhs.__isset.cellVisibility) {
    return lhs.__isset.cellVisibility < rhs.__isset.cellVisibility;
  }
  if (lhs.__isset.cellVisibility) {
    if (!(lhs.cellVisibility == rhs.cellVisibility)) {
      return lhs.cellVisibility < rhs.cellVisibility;
    }
  }
  return false;
}

const std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TColumnIncrement>& TIncrement::get_columns() const& {
  return columns;
}

std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TColumnIncrement> TIncrement::get_columns() && {
  return std::move(columns);
}

const std::map<std::string, std::string>* TIncrement::get_attributes() const& {
  return __isset.attributes ? std::addressof(attributes) : nullptr;
}

std::map<std::string, std::string>* TIncrement::get_attributes() & {
  return __isset.attributes ? std::addressof(attributes) : nullptr;
}

const  ::apache::hadoop::hbase::thrift2::cpp2::TCellVisibility* TIncrement::get_cellVisibility() const& {
  return __isset.cellVisibility ? std::addressof(cellVisibility) : nullptr;
}

 ::apache::hadoop::hbase::thrift2::cpp2::TCellVisibility* TIncrement::get_cellVisibility() & {
  return __isset.cellVisibility ? std::addressof(cellVisibility) : nullptr;
}


void swap(TIncrement& a, TIncrement& b) {
  using ::std::swap;
  swap(a.row, b.row);
  swap(a.columns, b.columns);
  swap(a.attributes, b.attributes);
  swap(a.durability, b.durability);
  swap(a.cellVisibility, b.cellVisibility);
  swap(a.__isset, b.__isset);
}

template void TIncrement::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t TIncrement::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t TIncrement::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t TIncrement::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void TIncrement::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t TIncrement::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t TIncrement::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t TIncrement::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}}}}} // apache::hadoop::hbase::thrift2::cpp2
namespace apache { namespace hadoop { namespace hbase { namespace thrift2 { namespace cpp2 {

TAppend::TAppend() :
      durability(static_cast< ::apache::hadoop::hbase::thrift2::cpp2::TDurability>(0)) {}


TAppend::~TAppend() {}

TAppend::TAppend(apache::thrift::FragileConstructor, std::string row__arg, std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TColumnValue> columns__arg, std::map<std::string, std::string> attributes__arg,  ::apache::hadoop::hbase::thrift2::cpp2::TDurability durability__arg,  ::apache::hadoop::hbase::thrift2::cpp2::TCellVisibility cellVisibility__arg) :
    row(std::move(row__arg)),
    columns(std::move(columns__arg)),
    attributes(std::move(attributes__arg)),
    durability(std::move(durability__arg)),
    cellVisibility(std::move(cellVisibility__arg)) {
  __isset.attributes = true;
  __isset.durability = true;
  __isset.cellVisibility = true;
}

void TAppend::__clear() {
  // clear all fields
  row = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  columns.clear();
  attributes.clear();
  durability = static_cast< ::apache::hadoop::hbase::thrift2::cpp2::TDurability>(0);
  ::apache::thrift::Cpp2Ops<  ::apache::hadoop::hbase::thrift2::cpp2::TCellVisibility>::clear(&cellVisibility);
  __isset = {};
}

bool TAppend::operator==(const TAppend& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.row, rhs.row)) {
    return false;
  }
  if (!(lhs.columns == rhs.columns)) {
    return false;
  }
  if (lhs.__isset.attributes != rhs.__isset.attributes) {
    return false;
  }
  if (lhs.__isset.attributes) {
    if (!(lhs.attributes == rhs.attributes)) {
      return false;
    }
  }
  if (lhs.__isset.durability != rhs.__isset.durability) {
    return false;
  }
  if (lhs.__isset.durability) {
    if (!(lhs.durability == rhs.durability)) {
      return false;
    }
  }
  if (lhs.__isset.cellVisibility != rhs.__isset.cellVisibility) {
    return false;
  }
  if (lhs.__isset.cellVisibility) {
    if (!(lhs.cellVisibility == rhs.cellVisibility)) {
      return false;
    }
  }
  return true;
}

bool TAppend::operator<(const TAppend& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.row, rhs.row)) {
    return apache::thrift::StringTraits<std::string>::isLess(lhs.row, rhs.row);
  }
  if (!(lhs.columns == rhs.columns)) {
    return lhs.columns < rhs.columns;
  }
  if (lhs.__isset.attributes != rhs.__isset.attributes) {
    return lhs.__isset.attributes < rhs.__isset.attributes;
  }
  if (lhs.__isset.attributes) {
    if (!(lhs.attributes == rhs.attributes)) {
      return lhs.attributes < rhs.attributes;
    }
  }
  if (lhs.__isset.durability != rhs.__isset.durability) {
    return lhs.__isset.durability < rhs.__isset.durability;
  }
  if (lhs.__isset.durability) {
    if (!(lhs.durability == rhs.durability)) {
      return lhs.durability < rhs.durability;
    }
  }
  if (lhs.__isset.cellVisibility != rhs.__isset.cellVisibility) {
    return lhs.__isset.cellVisibility < rhs.__isset.cellVisibility;
  }
  if (lhs.__isset.cellVisibility) {
    if (!(lhs.cellVisibility == rhs.cellVisibility)) {
      return lhs.cellVisibility < rhs.cellVisibility;
    }
  }
  return false;
}

const std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TColumnValue>& TAppend::get_columns() const& {
  return columns;
}

std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TColumnValue> TAppend::get_columns() && {
  return std::move(columns);
}

const std::map<std::string, std::string>* TAppend::get_attributes() const& {
  return __isset.attributes ? std::addressof(attributes) : nullptr;
}

std::map<std::string, std::string>* TAppend::get_attributes() & {
  return __isset.attributes ? std::addressof(attributes) : nullptr;
}

const  ::apache::hadoop::hbase::thrift2::cpp2::TCellVisibility* TAppend::get_cellVisibility() const& {
  return __isset.cellVisibility ? std::addressof(cellVisibility) : nullptr;
}

 ::apache::hadoop::hbase::thrift2::cpp2::TCellVisibility* TAppend::get_cellVisibility() & {
  return __isset.cellVisibility ? std::addressof(cellVisibility) : nullptr;
}


void swap(TAppend& a, TAppend& b) {
  using ::std::swap;
  swap(a.row, b.row);
  swap(a.columns, b.columns);
  swap(a.attributes, b.attributes);
  swap(a.durability, b.durability);
  swap(a.cellVisibility, b.cellVisibility);
  swap(a.__isset, b.__isset);
}

template void TAppend::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t TAppend::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t TAppend::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t TAppend::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void TAppend::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t TAppend::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t TAppend::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t TAppend::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}}}}} // apache::hadoop::hbase::thrift2::cpp2
namespace apache { namespace hadoop { namespace hbase { namespace thrift2 { namespace cpp2 {

TScan::TScan() :
      caching(0),
      maxVersions(1),
      batchSize(0),
      reversed(0),
      cacheBlocks(0),
      small(0) {}


TScan::~TScan() {}

TScan::TScan(apache::thrift::FragileConstructor, std::string startRow__arg, std::string stopRow__arg, std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TColumn> columns__arg, int32_t caching__arg, int32_t maxVersions__arg,  ::apache::hadoop::hbase::thrift2::cpp2::TTimeRange timeRange__arg, std::string filterString__arg, int32_t batchSize__arg, std::map<std::string, std::string> attributes__arg,  ::apache::hadoop::hbase::thrift2::cpp2::TAuthorization authorizations__arg, bool reversed__arg, bool cacheBlocks__arg, std::map<std::string,  ::apache::hadoop::hbase::thrift2::cpp2::TTimeRange> colFamTimeRangeMap__arg, bool small__arg) :
    startRow(std::move(startRow__arg)),
    stopRow(std::move(stopRow__arg)),
    columns(std::move(columns__arg)),
    caching(std::move(caching__arg)),
    maxVersions(std::move(maxVersions__arg)),
    timeRange(std::move(timeRange__arg)),
    filterString(std::move(filterString__arg)),
    batchSize(std::move(batchSize__arg)),
    attributes(std::move(attributes__arg)),
    authorizations(std::move(authorizations__arg)),
    reversed(std::move(reversed__arg)),
    cacheBlocks(std::move(cacheBlocks__arg)),
    colFamTimeRangeMap(std::move(colFamTimeRangeMap__arg)),
    small(std::move(small__arg)) {
  __isset.startRow = true;
  __isset.stopRow = true;
  __isset.columns = true;
  __isset.caching = true;
  __isset.maxVersions = true;
  __isset.timeRange = true;
  __isset.filterString = true;
  __isset.batchSize = true;
  __isset.attributes = true;
  __isset.authorizations = true;
  __isset.reversed = true;
  __isset.cacheBlocks = true;
  __isset.colFamTimeRangeMap = true;
  __isset.small = true;
}

void TScan::__clear() {
  // clear all fields
  startRow = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  stopRow = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  columns.clear();
  caching = 0;
  maxVersions = 1;
  ::apache::thrift::Cpp2Ops<  ::apache::hadoop::hbase::thrift2::cpp2::TTimeRange>::clear(&timeRange);
  filterString = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  batchSize = 0;
  attributes.clear();
  ::apache::thrift::Cpp2Ops<  ::apache::hadoop::hbase::thrift2::cpp2::TAuthorization>::clear(&authorizations);
  reversed = 0;
  cacheBlocks = 0;
  colFamTimeRangeMap.clear();
  small = 0;
  __isset = {};
}

bool TScan::operator==(const TScan& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.__isset.startRow != rhs.__isset.startRow) {
    return false;
  }
  if (lhs.__isset.startRow) {
    if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.startRow, rhs.startRow)) {
      return false;
    }
  }
  if (lhs.__isset.stopRow != rhs.__isset.stopRow) {
    return false;
  }
  if (lhs.__isset.stopRow) {
    if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.stopRow, rhs.stopRow)) {
      return false;
    }
  }
  if (lhs.__isset.columns != rhs.__isset.columns) {
    return false;
  }
  if (lhs.__isset.columns) {
    if (!(lhs.columns == rhs.columns)) {
      return false;
    }
  }
  if (lhs.__isset.caching != rhs.__isset.caching) {
    return false;
  }
  if (lhs.__isset.caching) {
    if (!(lhs.caching == rhs.caching)) {
      return false;
    }
  }
  if (lhs.__isset.maxVersions != rhs.__isset.maxVersions) {
    return false;
  }
  if (lhs.__isset.maxVersions) {
    if (!(lhs.maxVersions == rhs.maxVersions)) {
      return false;
    }
  }
  if (lhs.__isset.timeRange != rhs.__isset.timeRange) {
    return false;
  }
  if (lhs.__isset.timeRange) {
    if (!(lhs.timeRange == rhs.timeRange)) {
      return false;
    }
  }
  if (lhs.__isset.filterString != rhs.__isset.filterString) {
    return false;
  }
  if (lhs.__isset.filterString) {
    if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.filterString, rhs.filterString)) {
      return false;
    }
  }
  if (lhs.__isset.batchSize != rhs.__isset.batchSize) {
    return false;
  }
  if (lhs.__isset.batchSize) {
    if (!(lhs.batchSize == rhs.batchSize)) {
      return false;
    }
  }
  if (lhs.__isset.attributes != rhs.__isset.attributes) {
    return false;
  }
  if (lhs.__isset.attributes) {
    if (!(lhs.attributes == rhs.attributes)) {
      return false;
    }
  }
  if (lhs.__isset.authorizations != rhs.__isset.authorizations) {
    return false;
  }
  if (lhs.__isset.authorizations) {
    if (!(lhs.authorizations == rhs.authorizations)) {
      return false;
    }
  }
  if (lhs.__isset.reversed != rhs.__isset.reversed) {
    return false;
  }
  if (lhs.__isset.reversed) {
    if (!(lhs.reversed == rhs.reversed)) {
      return false;
    }
  }
  if (lhs.__isset.cacheBlocks != rhs.__isset.cacheBlocks) {
    return false;
  }
  if (lhs.__isset.cacheBlocks) {
    if (!(lhs.cacheBlocks == rhs.cacheBlocks)) {
      return false;
    }
  }
  if (lhs.__isset.colFamTimeRangeMap != rhs.__isset.colFamTimeRangeMap) {
    return false;
  }
  if (lhs.__isset.colFamTimeRangeMap) {
    if (!(lhs.colFamTimeRangeMap == rhs.colFamTimeRangeMap)) {
      return false;
    }
  }
  if (lhs.__isset.small != rhs.__isset.small) {
    return false;
  }
  if (lhs.__isset.small) {
    if (!(lhs.small == rhs.small)) {
      return false;
    }
  }
  return true;
}

bool TScan::operator<(const TScan& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.__isset.startRow != rhs.__isset.startRow) {
    return lhs.__isset.startRow < rhs.__isset.startRow;
  }
  if (lhs.__isset.startRow) {
    if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.startRow, rhs.startRow)) {
      return apache::thrift::StringTraits<std::string>::isLess(lhs.startRow, rhs.startRow);
    }
  }
  if (lhs.__isset.stopRow != rhs.__isset.stopRow) {
    return lhs.__isset.stopRow < rhs.__isset.stopRow;
  }
  if (lhs.__isset.stopRow) {
    if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.stopRow, rhs.stopRow)) {
      return apache::thrift::StringTraits<std::string>::isLess(lhs.stopRow, rhs.stopRow);
    }
  }
  if (lhs.__isset.columns != rhs.__isset.columns) {
    return lhs.__isset.columns < rhs.__isset.columns;
  }
  if (lhs.__isset.columns) {
    if (!(lhs.columns == rhs.columns)) {
      return lhs.columns < rhs.columns;
    }
  }
  if (lhs.__isset.caching != rhs.__isset.caching) {
    return lhs.__isset.caching < rhs.__isset.caching;
  }
  if (lhs.__isset.caching) {
    if (!(lhs.caching == rhs.caching)) {
      return lhs.caching < rhs.caching;
    }
  }
  if (lhs.__isset.maxVersions != rhs.__isset.maxVersions) {
    return lhs.__isset.maxVersions < rhs.__isset.maxVersions;
  }
  if (lhs.__isset.maxVersions) {
    if (!(lhs.maxVersions == rhs.maxVersions)) {
      return lhs.maxVersions < rhs.maxVersions;
    }
  }
  if (lhs.__isset.timeRange != rhs.__isset.timeRange) {
    return lhs.__isset.timeRange < rhs.__isset.timeRange;
  }
  if (lhs.__isset.timeRange) {
    if (!(lhs.timeRange == rhs.timeRange)) {
      return lhs.timeRange < rhs.timeRange;
    }
  }
  if (lhs.__isset.filterString != rhs.__isset.filterString) {
    return lhs.__isset.filterString < rhs.__isset.filterString;
  }
  if (lhs.__isset.filterString) {
    if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.filterString, rhs.filterString)) {
      return apache::thrift::StringTraits<std::string>::isLess(lhs.filterString, rhs.filterString);
    }
  }
  if (lhs.__isset.batchSize != rhs.__isset.batchSize) {
    return lhs.__isset.batchSize < rhs.__isset.batchSize;
  }
  if (lhs.__isset.batchSize) {
    if (!(lhs.batchSize == rhs.batchSize)) {
      return lhs.batchSize < rhs.batchSize;
    }
  }
  if (lhs.__isset.attributes != rhs.__isset.attributes) {
    return lhs.__isset.attributes < rhs.__isset.attributes;
  }
  if (lhs.__isset.attributes) {
    if (!(lhs.attributes == rhs.attributes)) {
      return lhs.attributes < rhs.attributes;
    }
  }
  if (lhs.__isset.authorizations != rhs.__isset.authorizations) {
    return lhs.__isset.authorizations < rhs.__isset.authorizations;
  }
  if (lhs.__isset.authorizations) {
    if (!(lhs.authorizations == rhs.authorizations)) {
      return lhs.authorizations < rhs.authorizations;
    }
  }
  if (lhs.__isset.reversed != rhs.__isset.reversed) {
    return lhs.__isset.reversed < rhs.__isset.reversed;
  }
  if (lhs.__isset.reversed) {
    if (!(lhs.reversed == rhs.reversed)) {
      return lhs.reversed < rhs.reversed;
    }
  }
  if (lhs.__isset.cacheBlocks != rhs.__isset.cacheBlocks) {
    return lhs.__isset.cacheBlocks < rhs.__isset.cacheBlocks;
  }
  if (lhs.__isset.cacheBlocks) {
    if (!(lhs.cacheBlocks == rhs.cacheBlocks)) {
      return lhs.cacheBlocks < rhs.cacheBlocks;
    }
  }
  if (lhs.__isset.colFamTimeRangeMap != rhs.__isset.colFamTimeRangeMap) {
    return lhs.__isset.colFamTimeRangeMap < rhs.__isset.colFamTimeRangeMap;
  }
  if (lhs.__isset.colFamTimeRangeMap) {
    if (!(lhs.colFamTimeRangeMap == rhs.colFamTimeRangeMap)) {
      return lhs.colFamTimeRangeMap < rhs.colFamTimeRangeMap;
    }
  }
  if (lhs.__isset.small != rhs.__isset.small) {
    return lhs.__isset.small < rhs.__isset.small;
  }
  if (lhs.__isset.small) {
    if (!(lhs.small == rhs.small)) {
      return lhs.small < rhs.small;
    }
  }
  return false;
}

const std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TColumn>* TScan::get_columns() const& {
  return __isset.columns ? std::addressof(columns) : nullptr;
}

std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TColumn>* TScan::get_columns() & {
  return __isset.columns ? std::addressof(columns) : nullptr;
}

const  ::apache::hadoop::hbase::thrift2::cpp2::TTimeRange* TScan::get_timeRange() const& {
  return __isset.timeRange ? std::addressof(timeRange) : nullptr;
}

 ::apache::hadoop::hbase::thrift2::cpp2::TTimeRange* TScan::get_timeRange() & {
  return __isset.timeRange ? std::addressof(timeRange) : nullptr;
}

const std::map<std::string, std::string>* TScan::get_attributes() const& {
  return __isset.attributes ? std::addressof(attributes) : nullptr;
}

std::map<std::string, std::string>* TScan::get_attributes() & {
  return __isset.attributes ? std::addressof(attributes) : nullptr;
}

const  ::apache::hadoop::hbase::thrift2::cpp2::TAuthorization* TScan::get_authorizations() const& {
  return __isset.authorizations ? std::addressof(authorizations) : nullptr;
}

 ::apache::hadoop::hbase::thrift2::cpp2::TAuthorization* TScan::get_authorizations() & {
  return __isset.authorizations ? std::addressof(authorizations) : nullptr;
}

const std::map<std::string,  ::apache::hadoop::hbase::thrift2::cpp2::TTimeRange>* TScan::get_colFamTimeRangeMap() const& {
  return __isset.colFamTimeRangeMap ? std::addressof(colFamTimeRangeMap) : nullptr;
}

std::map<std::string,  ::apache::hadoop::hbase::thrift2::cpp2::TTimeRange>* TScan::get_colFamTimeRangeMap() & {
  return __isset.colFamTimeRangeMap ? std::addressof(colFamTimeRangeMap) : nullptr;
}


void swap(TScan& a, TScan& b) {
  using ::std::swap;
  swap(a.startRow, b.startRow);
  swap(a.stopRow, b.stopRow);
  swap(a.columns, b.columns);
  swap(a.caching, b.caching);
  swap(a.maxVersions, b.maxVersions);
  swap(a.timeRange, b.timeRange);
  swap(a.filterString, b.filterString);
  swap(a.batchSize, b.batchSize);
  swap(a.attributes, b.attributes);
  swap(a.authorizations, b.authorizations);
  swap(a.reversed, b.reversed);
  swap(a.cacheBlocks, b.cacheBlocks);
  swap(a.colFamTimeRangeMap, b.colFamTimeRangeMap);
  swap(a.small, b.small);
  swap(a.__isset, b.__isset);
}

template void TScan::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t TScan::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t TScan::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t TScan::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void TScan::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t TScan::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t TScan::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t TScan::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}}}}} // apache::hadoop::hbase::thrift2::cpp2
namespace apache { namespace hadoop { namespace hbase { namespace thrift2 { namespace cpp2 {

void TMutation::__clear() {
  // clear all fields
  if (type_ == Type::__EMPTY__) { return; }
  switch(type_) {
    case Type::put:
    {
      destruct(value_.put);
      break;
    }
    case Type::deleteSingle:
    {
      destruct(value_.deleteSingle);
      break;
    }
    default:
    {
      assert(false);
      break;
    }
  }
  type_ = Type::__EMPTY__;
}

bool TMutation::operator==(const TMutation& rhs) const {
  if (type_ != rhs.type_) { return false; }
  switch(type_) {
    case Type::put:
    {
      return value_.put == rhs.value_.put;
    }
    case Type::deleteSingle:
    {
      return value_.deleteSingle == rhs.value_.deleteSingle;
    }
    default:
    {
      return true;
    }
  }
}

void swap(TMutation& a, TMutation& b) {
  TMutation temp(std::move(a));
  a = std::move(b);
  b = std::move(temp);
}

template void TMutation::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t TMutation::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t TMutation::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t TMutation::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void TMutation::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t TMutation::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t TMutation::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t TMutation::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}}}}} // apache::hadoop::hbase::thrift2::cpp2
namespace apache { namespace hadoop { namespace hbase { namespace thrift2 { namespace cpp2 {

TRowMutations::TRowMutations(apache::thrift::FragileConstructor, std::string row__arg, std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TMutation> mutations__arg) :
    row(std::move(row__arg)),
    mutations(std::move(mutations__arg)) {}

void TRowMutations::__clear() {
  // clear all fields
  row = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  mutations.clear();
}

bool TRowMutations::operator==(const TRowMutations& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.row, rhs.row)) {
    return false;
  }
  if (!(lhs.mutations == rhs.mutations)) {
    return false;
  }
  return true;
}

bool TRowMutations::operator<(const TRowMutations& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.row, rhs.row)) {
    return apache::thrift::StringTraits<std::string>::isLess(lhs.row, rhs.row);
  }
  if (!(lhs.mutations == rhs.mutations)) {
    return lhs.mutations < rhs.mutations;
  }
  return false;
}

const std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TMutation>& TRowMutations::get_mutations() const& {
  return mutations;
}

std::vector< ::apache::hadoop::hbase::thrift2::cpp2::TMutation> TRowMutations::get_mutations() && {
  return std::move(mutations);
}


void swap(TRowMutations& a, TRowMutations& b) {
  using ::std::swap;
  swap(a.row, b.row);
  swap(a.mutations, b.mutations);
}

template void TRowMutations::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t TRowMutations::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t TRowMutations::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t TRowMutations::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void TRowMutations::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t TRowMutations::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t TRowMutations::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t TRowMutations::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}}}}} // apache::hadoop::hbase::thrift2::cpp2
namespace apache { namespace hadoop { namespace hbase { namespace thrift2 { namespace cpp2 {

THRegionInfo::THRegionInfo() :
      regionId(0),
      offline(0),
      split(0),
      replicaId(0) {}


THRegionInfo::~THRegionInfo() {}

THRegionInfo::THRegionInfo(apache::thrift::FragileConstructor, int64_t regionId__arg, std::string tableName__arg, std::string startKey__arg, std::string endKey__arg, bool offline__arg, bool split__arg, int32_t replicaId__arg) :
    regionId(std::move(regionId__arg)),
    tableName(std::move(tableName__arg)),
    startKey(std::move(startKey__arg)),
    endKey(std::move(endKey__arg)),
    offline(std::move(offline__arg)),
    split(std::move(split__arg)),
    replicaId(std::move(replicaId__arg)) {
  __isset.startKey = true;
  __isset.endKey = true;
  __isset.offline = true;
  __isset.split = true;
  __isset.replicaId = true;
}

void THRegionInfo::__clear() {
  // clear all fields
  regionId = 0;
  tableName = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  startKey = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  endKey = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  offline = 0;
  split = 0;
  replicaId = 0;
  __isset = {};
}

bool THRegionInfo::operator==(const THRegionInfo& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.regionId == rhs.regionId)) {
    return false;
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.tableName, rhs.tableName)) {
    return false;
  }
  if (lhs.__isset.startKey != rhs.__isset.startKey) {
    return false;
  }
  if (lhs.__isset.startKey) {
    if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.startKey, rhs.startKey)) {
      return false;
    }
  }
  if (lhs.__isset.endKey != rhs.__isset.endKey) {
    return false;
  }
  if (lhs.__isset.endKey) {
    if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.endKey, rhs.endKey)) {
      return false;
    }
  }
  if (lhs.__isset.offline != rhs.__isset.offline) {
    return false;
  }
  if (lhs.__isset.offline) {
    if (!(lhs.offline == rhs.offline)) {
      return false;
    }
  }
  if (lhs.__isset.split != rhs.__isset.split) {
    return false;
  }
  if (lhs.__isset.split) {
    if (!(lhs.split == rhs.split)) {
      return false;
    }
  }
  if (lhs.__isset.replicaId != rhs.__isset.replicaId) {
    return false;
  }
  if (lhs.__isset.replicaId) {
    if (!(lhs.replicaId == rhs.replicaId)) {
      return false;
    }
  }
  return true;
}

bool THRegionInfo::operator<(const THRegionInfo& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.regionId == rhs.regionId)) {
    return lhs.regionId < rhs.regionId;
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.tableName, rhs.tableName)) {
    return apache::thrift::StringTraits<std::string>::isLess(lhs.tableName, rhs.tableName);
  }
  if (lhs.__isset.startKey != rhs.__isset.startKey) {
    return lhs.__isset.startKey < rhs.__isset.startKey;
  }
  if (lhs.__isset.startKey) {
    if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.startKey, rhs.startKey)) {
      return apache::thrift::StringTraits<std::string>::isLess(lhs.startKey, rhs.startKey);
    }
  }
  if (lhs.__isset.endKey != rhs.__isset.endKey) {
    return lhs.__isset.endKey < rhs.__isset.endKey;
  }
  if (lhs.__isset.endKey) {
    if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.endKey, rhs.endKey)) {
      return apache::thrift::StringTraits<std::string>::isLess(lhs.endKey, rhs.endKey);
    }
  }
  if (lhs.__isset.offline != rhs.__isset.offline) {
    return lhs.__isset.offline < rhs.__isset.offline;
  }
  if (lhs.__isset.offline) {
    if (!(lhs.offline == rhs.offline)) {
      return lhs.offline < rhs.offline;
    }
  }
  if (lhs.__isset.split != rhs.__isset.split) {
    return lhs.__isset.split < rhs.__isset.split;
  }
  if (lhs.__isset.split) {
    if (!(lhs.split == rhs.split)) {
      return lhs.split < rhs.split;
    }
  }
  if (lhs.__isset.replicaId != rhs.__isset.replicaId) {
    return lhs.__isset.replicaId < rhs.__isset.replicaId;
  }
  if (lhs.__isset.replicaId) {
    if (!(lhs.replicaId == rhs.replicaId)) {
      return lhs.replicaId < rhs.replicaId;
    }
  }
  return false;
}


void swap(THRegionInfo& a, THRegionInfo& b) {
  using ::std::swap;
  swap(a.regionId, b.regionId);
  swap(a.tableName, b.tableName);
  swap(a.startKey, b.startKey);
  swap(a.endKey, b.endKey);
  swap(a.offline, b.offline);
  swap(a.split, b.split);
  swap(a.replicaId, b.replicaId);
  swap(a.__isset, b.__isset);
}

template void THRegionInfo::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t THRegionInfo::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t THRegionInfo::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t THRegionInfo::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void THRegionInfo::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t THRegionInfo::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t THRegionInfo::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t THRegionInfo::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}}}}} // apache::hadoop::hbase::thrift2::cpp2
namespace apache { namespace hadoop { namespace hbase { namespace thrift2 { namespace cpp2 {

TServerName::TServerName(apache::thrift::FragileConstructor, std::string hostName__arg, int32_t port__arg, int64_t startCode__arg) :
    hostName(std::move(hostName__arg)),
    port(std::move(port__arg)),
    startCode(std::move(startCode__arg)) {
  __isset.port = true;
  __isset.startCode = true;
}

void TServerName::__clear() {
  // clear all fields
  hostName = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  port = 0;
  startCode = 0;
  __isset = {};
}

bool TServerName::operator==(const TServerName& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.hostName == rhs.hostName)) {
    return false;
  }
  if (lhs.__isset.port != rhs.__isset.port) {
    return false;
  }
  if (lhs.__isset.port) {
    if (!(lhs.port == rhs.port)) {
      return false;
    }
  }
  if (lhs.__isset.startCode != rhs.__isset.startCode) {
    return false;
  }
  if (lhs.__isset.startCode) {
    if (!(lhs.startCode == rhs.startCode)) {
      return false;
    }
  }
  return true;
}

bool TServerName::operator<(const TServerName& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.hostName == rhs.hostName)) {
    return lhs.hostName < rhs.hostName;
  }
  if (lhs.__isset.port != rhs.__isset.port) {
    return lhs.__isset.port < rhs.__isset.port;
  }
  if (lhs.__isset.port) {
    if (!(lhs.port == rhs.port)) {
      return lhs.port < rhs.port;
    }
  }
  if (lhs.__isset.startCode != rhs.__isset.startCode) {
    return lhs.__isset.startCode < rhs.__isset.startCode;
  }
  if (lhs.__isset.startCode) {
    if (!(lhs.startCode == rhs.startCode)) {
      return lhs.startCode < rhs.startCode;
    }
  }
  return false;
}


void swap(TServerName& a, TServerName& b) {
  using ::std::swap;
  swap(a.hostName, b.hostName);
  swap(a.port, b.port);
  swap(a.startCode, b.startCode);
  swap(a.__isset, b.__isset);
}

template void TServerName::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t TServerName::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t TServerName::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t TServerName::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void TServerName::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t TServerName::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t TServerName::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t TServerName::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}}}}} // apache::hadoop::hbase::thrift2::cpp2
namespace apache { namespace hadoop { namespace hbase { namespace thrift2 { namespace cpp2 {

THRegionLocation::THRegionLocation(apache::thrift::FragileConstructor,  ::apache::hadoop::hbase::thrift2::cpp2::TServerName serverName__arg,  ::apache::hadoop::hbase::thrift2::cpp2::THRegionInfo regionInfo__arg) :
    serverName(std::move(serverName__arg)),
    regionInfo(std::move(regionInfo__arg)) {}

void THRegionLocation::__clear() {
  // clear all fields
  ::apache::thrift::Cpp2Ops<  ::apache::hadoop::hbase::thrift2::cpp2::TServerName>::clear(&serverName);
  ::apache::thrift::Cpp2Ops<  ::apache::hadoop::hbase::thrift2::cpp2::THRegionInfo>::clear(&regionInfo);
}

bool THRegionLocation::operator==(const THRegionLocation& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.serverName == rhs.serverName)) {
    return false;
  }
  if (!(lhs.regionInfo == rhs.regionInfo)) {
    return false;
  }
  return true;
}

bool THRegionLocation::operator<(const THRegionLocation& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.serverName == rhs.serverName)) {
    return lhs.serverName < rhs.serverName;
  }
  if (!(lhs.regionInfo == rhs.regionInfo)) {
    return lhs.regionInfo < rhs.regionInfo;
  }
  return false;
}

const  ::apache::hadoop::hbase::thrift2::cpp2::TServerName& THRegionLocation::get_serverName() const& {
  return serverName;
}

 ::apache::hadoop::hbase::thrift2::cpp2::TServerName THRegionLocation::get_serverName() && {
  return std::move(serverName);
}

const  ::apache::hadoop::hbase::thrift2::cpp2::THRegionInfo& THRegionLocation::get_regionInfo() const& {
  return regionInfo;
}

 ::apache::hadoop::hbase::thrift2::cpp2::THRegionInfo THRegionLocation::get_regionInfo() && {
  return std::move(regionInfo);
}


void swap(THRegionLocation& a, THRegionLocation& b) {
  using ::std::swap;
  swap(a.serverName, b.serverName);
  swap(a.regionInfo, b.regionInfo);
}

template void THRegionLocation::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t THRegionLocation::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t THRegionLocation::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t THRegionLocation::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void THRegionLocation::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t THRegionLocation::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t THRegionLocation::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t THRegionLocation::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}}}}} // apache::hadoop::hbase::thrift2::cpp2
namespace apache { namespace hadoop { namespace hbase { namespace thrift2 { namespace cpp2 {

TIOError::TIOError(apache::thrift::FragileConstructor, std::string message__arg) :
    message(std::move(message__arg)) {
  __isset.message = true;
}

void TIOError::__clear() {
  // clear all fields
  message = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  __isset = {};
}

bool TIOError::operator==(const TIOError& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.__isset.message != rhs.__isset.message) {
    return false;
  }
  if (lhs.__isset.message) {
    if (!(lhs.message == rhs.message)) {
      return false;
    }
  }
  return true;
}

bool TIOError::operator<(const TIOError& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.__isset.message != rhs.__isset.message) {
    return lhs.__isset.message < rhs.__isset.message;
  }
  if (lhs.__isset.message) {
    if (!(lhs.message == rhs.message)) {
      return lhs.message < rhs.message;
    }
  }
  return false;
}


void swap(TIOError& a, TIOError& b) {
  using ::std::swap;
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

template void TIOError::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t TIOError::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t TIOError::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t TIOError::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void TIOError::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t TIOError::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t TIOError::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t TIOError::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}}}}} // apache::hadoop::hbase::thrift2::cpp2
namespace apache { namespace hadoop { namespace hbase { namespace thrift2 { namespace cpp2 {

TIllegalArgument::TIllegalArgument(apache::thrift::FragileConstructor, std::string message__arg) :
    message(std::move(message__arg)) {
  __isset.message = true;
}

void TIllegalArgument::__clear() {
  // clear all fields
  message = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  __isset = {};
}

bool TIllegalArgument::operator==(const TIllegalArgument& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.__isset.message != rhs.__isset.message) {
    return false;
  }
  if (lhs.__isset.message) {
    if (!(lhs.message == rhs.message)) {
      return false;
    }
  }
  return true;
}

bool TIllegalArgument::operator<(const TIllegalArgument& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.__isset.message != rhs.__isset.message) {
    return lhs.__isset.message < rhs.__isset.message;
  }
  if (lhs.__isset.message) {
    if (!(lhs.message == rhs.message)) {
      return lhs.message < rhs.message;
    }
  }
  return false;
}


void swap(TIllegalArgument& a, TIllegalArgument& b) {
  using ::std::swap;
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

template void TIllegalArgument::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t TIllegalArgument::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t TIllegalArgument::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t TIllegalArgument::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void TIllegalArgument::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t TIllegalArgument::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t TIllegalArgument::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t TIllegalArgument::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}}}}} // apache::hadoop::hbase::thrift2::cpp2
