/* Copyright (c) 2020 vesoft inc. All rights reserved.
 *
 * This source code is licensed under Apache 2.0 License.
 */

#include "graph/optimizer/OptGroup.h"

#include <limits>

#include "graph/context/QueryContext.h"
#include "graph/optimizer/OptContext.h"
#include "graph/optimizer/OptRule.h"
#include "graph/planner/plan/Logic.h"
#include "graph/planner/plan/PlanNode.h"

using nebula::graph::BinaryInputNode;
using nebula::graph::Loop;
using nebula::graph::PlanNode;
using nebula::graph::QueryContext;
using nebula::graph::Select;
using nebula::graph::SingleDependencyNode;

namespace nebula {
namespace opt {

OptGroup *OptGroup::create(OptContext *ctx) {
  return ctx->objPool()->makeAndAdd<OptGroup>(ctx);
}

void OptGroup::setUnexplored(const OptRule *rule) {
  if (!ctx_->visited_.emplace(this).second) {
    return;
  }
  auto iter = std::find(exploredRules_.begin(), exploredRules_.end(), rule);
  if (iter != exploredRules_.end()) {
    exploredRules_.erase(iter);
  }
  for (auto node : groupNodes_) {
    node->setUnexplored(rule);
  }
}

OptGroup::OptGroup(OptContext *ctx) noexcept : ctx_(ctx) {
  DCHECK(ctx != nullptr);
}

Status OptGroup::validateSubPlan(const OptGroupNode *gn,
                                 const OptRule *rule,
                                 const std::vector<OptGroup *> &patternLeaves) const {
  auto &deps = DCHECK_NOTNULL(gn)->dependencies();

  auto checkDepGroup = [this, gn, rule, &patternLeaves](const OptGroup *depGroup) -> Status {
    auto iter = std::find(patternLeaves.begin(), patternLeaves.end(), depGroup);
    if (iter != patternLeaves.end()) {
      return Status::OK();
    }
    if (!depGroup) {
      return Status::Error("Could not find the dependent group in pattern leaves");
    }
    if (depGroup->groupNodes_.size() != 1U || depGroup->groupNodesReferenced_.size() != 1U) {
      return Status::Error(
          "Invalid sub-plan generated when applying the rule: %s, "
          "planNode: %s, numGroupNodes: %lu, numGroupNodesRef: %lu",
          rule->toString().c_str(),
          PlanNode::toString(gn->node()->kind()),
          depGroup->groupNodes_.size(),
          depGroup->groupNodesReferenced_.size());
    }
    return validateSubPlan(depGroup->groupNodes_.front(), rule, patternLeaves);
  };

  switch (deps.size()) {
    case 0: {
      auto iter = std::find(patternLeaves.begin(), patternLeaves.end(), nullptr);
      if (iter == patternLeaves.end()) {
        return Status::Error("Invalid sub-plan generated by the rule: %s, planNode: %s",
                             rule->toString().c_str(),
                             PlanNode::toString(gn->node()->kind()));
      }
      break;
    }
    case 1: {
      NG_RETURN_IF_ERROR(checkDepGroup(deps[0]));
      break;
    }
    case 2: {
      NG_RETURN_IF_ERROR(checkDepGroup(deps[0]));
      NG_RETURN_IF_ERROR(checkDepGroup(deps[1]));
      break;
    }
    default: {
      return Status::Error("Invalid dependencies of opt group node: %lu", deps.size());
    }
  }
  return Status::OK();
}

Status OptGroup::validate(const OptRule *rule) const {
  if (groupNodes_.empty() && !groupNodesReferenced_.empty()) {
    return Status::Error(
        "The OptGroup has no any OptGroupNode but used by other OptGroupNode "
        "when applying the rule: %s, numGroupNodesRef: %lu",
        rule->toString().c_str(),
        groupNodesReferenced_.size());
  }
  if (!ctx_->visited_.emplace(this).second) {
    return Status::OK();
  }
  for (auto *gn : groupNodes_) {
    NG_RETURN_IF_ERROR(gn->validate(rule));
    if (gn->node()->outputVar() != outputVar_) {
      return Status::Error(
          "The output columns of the OptGroupNode is different from OptGroup "
          "when applying the rule: %s, %s vs. %s",
          rule->toString().c_str(),
          gn->node()->outputVar().c_str(),
          outputVar_.c_str());
    }
  }
  return Status::OK();
}

void OptGroup::addGroupNode(OptGroupNode *groupNode) {
  DCHECK_EQ(this, DCHECK_NOTNULL(groupNode)->group());
  if (outputVar_.empty()) {
    outputVar_ = groupNode->node()->outputVar();
  } else {
    DCHECK_EQ(outputVar_, groupNode->node()->outputVar())
        << "outputVar_: " << outputVar_ << "groupNode plan: " << groupNode->node()->toString()
        << ", groupNode->node()->outputVar(): " << groupNode->node()->outputVar();
  }
  groupNodes_.emplace_back(groupNode);
  groupNode->node()->updateSymbols();
}

OptGroupNode *OptGroup::makeGroupNode(PlanNode *node) {
  auto *gn = OptGroupNode::create(ctx_, node, this);
  addGroupNode(gn);
  return gn;
}

Status OptGroup::explore(const OptRule *rule) {
  if (isExplored(rule)) {
    return Status::OK();
  }
  setExplored(rule);
  if (!ctx_->visited_.emplace(this).second) {
    return Status::OK();
  }

  // TODO(yee): the opt group maybe in the loop body branch
  // DCHECK(isRootGroup_ || !groupNodesReferenced_.empty())
  //     << "Current group should be referenced by other group nodes before optimization";

  for (auto iter = groupNodes_.begin(); iter != groupNodes_.end();) {
    auto *groupNode = DCHECK_NOTNULL(*iter);
    if (groupNode->isExplored(rule)) {
      ++iter;
      continue;
    }
    // Bottom to up exploration
    NG_RETURN_IF_ERROR(groupNode->explore(rule));

    // Find more equivalents
    std::vector<OptGroup *> leaves;
    auto status = rule->match(ctx_, groupNode);
    if (!status.ok()) {
      ++iter;
      continue;
    }
    ctx_->setChanged(true);
    auto matched = std::move(status).value();
    matched.collectPatternLeaves(leaves);
    auto resStatus = rule->transform(ctx_, matched);
    NG_RETURN_IF_ERROR(resStatus);
    auto result = std::move(resStatus).value();

    for (auto *gn : result.newGroupNodes) {
      auto it = std::find(groupNodes_.begin(), groupNodes_.end(), gn);
      if (it != groupNodes_.end()) {
        return Status::Error("Should not push the OptGroupNode %s into the group in the rule: %s",
                             gn->node()->toString().c_str(),
                             rule->toString().c_str());
      }
    }

    // In some cases, we can apply optimization rules even if the control flow and data flow are
    // inconsistent. For now, let the optimization rules themselves guarantee correctness.
    if (result.eraseAll) {
      for (auto gnode : groupNodes_) {
        gnode->release();
      }
      groupNodes_.clear();
      for (auto ngn : result.newGroupNodes) {
        addGroupNode(ngn);
      }
      break;
    }

    if (!result.newGroupNodes.empty()) {
      for (auto ngn : result.newGroupNodes) {
        addGroupNode(ngn);
      }

      setUnexplored(rule);
    }

    if (result.eraseCurr) {
      (*iter)->release();
      iter = groupNodes_.erase(iter);
    } else {
      ++iter;
    }
  }

  DCHECK(!groupNodes_.empty())
      << "Should have at least one group node after optimizing the current group";

  return Status::OK();
}

Status OptGroup::exploreUntilMaxRound(const OptRule *rule) {
  auto maxRound = kMaxExplorationRound;
  while (!isExplored(rule)) {
    if (0 >= maxRound--) {
      setExplored(rule);
      break;
    }
    NG_RETURN_IF_ERROR(explore(rule));
  }
  return Status::OK();
}

std::pair<double, const OptGroupNode *> OptGroup::findMinCostGroupNode() const {
  DCHECK(!groupNodes_.empty()) << "There is no any group nodes in opt group";
  double minCost = std::numeric_limits<double>::max();
  const OptGroupNode *minGroupNode = nullptr;
  for (auto &groupNode : groupNodes_) {
    double cost = groupNode->getCost();
    if (minCost > cost) {
      minCost = cost;
      minGroupNode = groupNode;
    }
  }
  return std::make_pair(minCost, minGroupNode);
}

double OptGroup::getCost() const {
  return findMinCostGroupNode().first;
}

const PlanNode *OptGroup::getPlan() const {
  auto &group2PlanNodeMap = ctx_->group2PlanNodeMap_;
  auto iter = group2PlanNodeMap.find(this);
  if (iter != group2PlanNodeMap.end()) {
    return iter->second;
  }
  const OptGroupNode *minGroupNode = findMinCostGroupNode().second;
  const auto plan = DCHECK_NOTNULL(minGroupNode)->getPlan();
  group2PlanNodeMap.emplace(this, plan);
  return plan;
}

void OptGroup::deleteRefGroupNode(const OptGroupNode *node) {
  groupNodesReferenced_.erase(node);
  if (groupNodesReferenced_.empty()) {
    // Cleanup all opt group nodes in current opt group if it's NOT referenced by any other opt
    // group nodes
    for (auto *n : groupNodes_) {
      n->release();
    }
    groupNodes_.clear();
  }
}

OptGroupNode *OptGroupNode::create(OptContext *ctx, PlanNode *node, const OptGroup *group) {
  auto optGNode = ctx->objPool()->makeAndAdd<OptGroupNode>(node, group);
  ctx->addPlanNodeAndOptGroupNode(node->id(), optGNode);
  return optGNode;
}

void OptGroupNode::setUnexplored(const OptRule *rule) {
  auto iter = std::find(exploredRules_.begin(), exploredRules_.end(), rule);
  if (iter != exploredRules_.end()) {
    exploredRules_.erase(iter);
  }
  for (auto dep : dependencies_) {
    dep->setUnexplored(rule);
  }
  for (auto body : bodies_) {
    body->setUnexplored(rule);
  }
}

OptGroupNode::OptGroupNode(PlanNode *node, const OptGroup *group) noexcept
    : node_(node), group_(group) {
  DCHECK(node != nullptr);
  DCHECK(group != nullptr);
}

Status OptGroupNode::explore(const OptRule *rule) {
  if (isExplored(rule)) {
    return Status::OK();
  }
  setExplored(rule);

  for (auto dep : dependencies_) {
    DCHECK(dep != nullptr);
    NG_RETURN_IF_ERROR(dep->exploreUntilMaxRound(rule));
  }

  for (auto body : bodies_) {
    DCHECK(body != nullptr);
    NG_RETURN_IF_ERROR(body->exploreUntilMaxRound(rule));
  }
  return Status::OK();
}

double OptGroupNode::getCost() const {
  return node_->cost();
}

const PlanNode *OptGroupNode::getPlan() const {
  if (node_->kind() == PlanNode::Kind::kSelect) {
    DCHECK_EQ(bodies_.size(), 2U);
    auto select = static_cast<Select *>(node_);
    select->setIf(const_cast<PlanNode *>(bodies_[0]->getPlan()));
    select->setElse(const_cast<PlanNode *>(bodies_[1]->getPlan()));
  } else if (node_->kind() == PlanNode::Kind::kLoop) {
    DCHECK_EQ(bodies_.size(), 1U);
    auto loop = static_cast<Loop *>(node_);
    loop->setBody(const_cast<PlanNode *>(bodies_[0]->getPlan()));
  }
  DCHECK_EQ(node_->numDeps(), dependencies_.size());
  for (size_t i = 0; i < node_->numDeps(); ++i) {
    node_->setDep(i, dependencies_[i]->getPlan());
  }
  return node_;
}

void OptGroupNode::release() {
  node_->releaseSymbols();
  for (auto *dep : dependencies_) {
    dep->deleteRefGroupNode(this);
  }
}

Status OptGroupNode::validate(const OptRule *rule) const {
  if (!node_) {
    return Status::Error("The OptGroupNode does not have plan node when applying the rule: %s",
                         rule->toString().c_str());
  }
  if (!group_) {
    return Status::Error(
        "The OptGroupNode does not have the right OptGroup when applying the rule: %s",
        rule->toString().c_str());
  }
  if (!bodies_.empty()) {
    if (node_->kind() != PlanNode::Kind::kLoop) {
      return Status::Error(
          "The plan node is not Loop in OptGroupNode when applying the rule: %s, planNode: %s",
          rule->toString().c_str(),
          PlanNode::toString(node_->kind()));
    }
    for (auto *g : bodies_) {
      NG_RETURN_IF_ERROR(g->validate(rule));
    }
  }
  if (dependencies_.empty()) {
    if (node_->kind() != PlanNode::Kind::kStart && node_->kind() != PlanNode::Kind::kArgument) {
      return Status::Error(
          "The leaf plan node is not Start or Argument in OptGroupNode when applying the rule: %s, "
          "planNode: %s",
          rule->toString().c_str(),
          PlanNode::toString(node_->kind()));
    }
  } else {
    for (auto *g : dependencies_) {
      NG_RETURN_IF_ERROR(g->validate(rule));
    }
  }
  return Status::OK();
}

}  // namespace opt
}  // namespace nebula
