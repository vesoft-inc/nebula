/* Copyright (c) 2020 vesoft inc. All rights reserved.
 *
 * This source code is licensed under Apache 2.0 License,
 * attached with Common Clause Condition 1.0, found in the LICENSES directory.
 */

#ifndef STORAGE_INDEXPOLICYMAKER_H
#define STORAGE_INDEXPOLICYMAKER_H
#include "base/Base.h"
#include "meta/SchemaManager.h"
#include "storage/CommonUtils.h"

namespace nebula {
namespace storage {

enum class PolicyType : uint8_t {
    /**
     * Not optimized, PolicyScanType will be invalid here. default using SEEK_SCAN.
     */
    SIMPLE_POLICY      = 0x01,
    /**
     * Scan policy optimized,  PolicyScanType will be valid here.
     */
    OPTIMIZED_POLICY   = 0x02,
};

enum class PolicyScanType : uint8_t {
    /**
     * No index column match. seek scan and using expression condition filter.
     */
    SEEK_SCAN          = 0x01,
    /**
     * Few index column match, index scan in subset.
     * And using expression condition filter for remaining index column.s
     */
    PREFIX_SCAN        = 0x02,
    /**
     * accurate scan, Fit all filter conditions. The results are accurate,
     * so no more filter is needed.
     */
    ACCURATE_SCAN      = 0x03,
};

/**
 * OperatorList used record all scan filters, before create scan policy,
 * need collect all columns and values for prefix string.
 * std::vector<std::pair<col_name, value>, equivalent_scan_or_not>
 */
using OperatorList = std::vector<std::pair<std::pair<std::string, VariantType>, bool>>;

class IndexPolicyMaker {
public:
    virtual ~IndexPolicyMaker() = default;

protected:
    explicit IndexPolicyMaker(meta::SchemaManager *schemaMan)
        : schemaMan_(schemaMan) {}

    /**
     * Details Entry method of index scan policy preparation, process logic as below :
     *         1, Trigger optimizer to optimize expression nodes
     *         2, Traverse the optimized expression, analyze and confirm PolicyType,
     *            confirm scanning mode.
     * Param  filter : From encoded string of where clause.
     * Return ErrorCode
     **/
    cpp2::ErrorCode policyPrepare(const std::string& filter);

    /**
     * Details Index scan policy generator. Confirm how to generate the scan policy
     *         through the information generated by policyPrepare. Generate corresponding
     *         execution policy according to PolicyType.
     *         In this method, it is best to use as many index columns as possible.
     **/
    void policyGenerate();

    /**
     * Details Evaluate filter conditions.
     */
    bool exprEval(Getters &getters);

private:
    void initPolicy();

    /**
     * Details Entry method of expresion traverse.
     */

    cpp2::ErrorCode prepareExpr(const Expression* expr);

protected:
    meta::SchemaManager*               schemaMan_{nullptr};
    std::unique_ptr<ExpressionContext> expCtx_{nullptr};
    std::unique_ptr<Expression>        exp_{nullptr};
    nebula::cpp2::IndexItem            index_;
    std::vector<VariantType>           policies_;
    PolicyType                         policyType_{PolicyType::OPTIMIZED_POLICY};
    PolicyScanType                     policyScanType_{PolicyScanType::SEEK_SCAN};
    OperatorList                       operatorList_;
};
}  // namespace storage
}  // namespace nebula
#endif  // STORAGE_INDEXPOLICYMAKER_H
